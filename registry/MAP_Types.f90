!STARTOFREGISTRYGENERATEDFILE './MAP_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry (v2.03.00, 2-May-2014)
!*********************************************************************************************************************************
! MAP_Types
!.................................................................................................................................
! This file is part of MAP.
!
! Copyright (C) 2012-2014 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
MODULE MAP_Types
! This module contains all of the user-defined types needed in MAP. It also contains copy, destroy, pack, and
! unpack routines associated with each defined data type. This code will be generated by the FAST Registry.
!---------------------------------------------------------------------------------------------------------------------------------
USE MAP_C_Types
!USE, INTRINSIC :: ISO_C_Binding
USE NWTC_Library
IMPLICIT NONE
! =========  MAP_InitInputType_C  =======
  TYPE, BIND(C) :: MAP_InitInputType_C
    TYPE( MAP_InitInput_C ) :: object
    REAL(KIND=C_DOUBLE) :: gravity 
    REAL(KIND=C_DOUBLE) :: seaDensity 
    REAL(KIND=C_DOUBLE) :: depth 
    CHARACTER(KIND=C_CHAR,LEN=255) :: fileName 
    CHARACTER(KIND=C_CHAR,LEN=255) :: summaryFileName 
    CHARACTER(KIND=C_CHAR,LEN=255) :: libraryInputLine 
    CHARACTER(KIND=C_CHAR,LEN=255) :: nodeInputLine 
    CHARACTER(KIND=C_CHAR,LEN=255) :: elementInputLine 
    CHARACTER(KIND=C_CHAR,LEN=255) :: optionInputLine 
  END TYPE MAP_InitInputType_C
  TYPE, PUBLIC :: MAP_InitInputType
    TYPE( c_ptr ) :: MAP_UserData = C_NULL_ptr
    TYPE( MAP_InitInputType_C ) :: C_obj
    REAL(DbKi)  :: gravity = -999.9      ! gravity constant [[m/s^2]]
    REAL(DbKi)  :: seaDensity = -999.9      ! sea density [[kg/m^3]]
    REAL(DbKi)  :: depth = -999.9      ! depth of water [[m]]
    CHARACTER(255)  :: fileName      ! MAP input file [-]
    CHARACTER(255)  :: summaryFileName      ! MAP summary file name [-]
    CHARACTER(255)  :: libraryInputLine      ! cable library string information (from input file) [-]
    CHARACTER(255)  :: nodeInputLine      ! node string information (from input file) [-]
    CHARACTER(255)  :: elementInputLine      ! element library string information (from input file) [-]
    CHARACTER(255)  :: optionInputLine      ! solver options library string information (from input file) [-]
  END TYPE MAP_InitInputType
! =======================
! =========  MAP_InitOutputType  =======
  TYPE, BIND(C) :: MAP_InitOutputType_C
    TYPE( MAP_InitOutput_C ) :: object
    CHARACTER(KIND=C_CHAR,LEN=99) :: progName 
    CHARACTER(KIND=C_CHAR,LEN=99) :: version 
    CHARACTER(KIND=C_CHAR,LEN=24) :: compilingData 
    TYPE(C_ptr) :: writeOutputHdr = C_NULL_PTR 
    INTEGER(C_int) :: writeOutputHdr_Len = 0 
    TYPE(C_ptr) :: writeOutputUnt = C_NULL_PTR 
    INTEGER(C_int) :: writeOutputUnt_Len = 0 
  END TYPE MAP_InitOutputType_C
  TYPE, PUBLIC :: MAP_InitOutputType
    TYPE( c_ptr ) :: MAP_UserData = C_NULL_ptr
    TYPE( MAP_InitOutputType_C ) :: C_obj
    CHARACTER(99)  :: progName      ! program name [-]
    CHARACTER(99)  :: version      ! version numnber [-]
    CHARACTER(24)  :: compilingData      ! compiling data [-]
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: writeOutputHdr      ! first line output file contents: output variable names [-]
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: writeOutputUnt      ! second line of output file contents: units [-]
    TYPE(ProgDesc)  :: Ver      ! his module's name, version, and date [-]
  END TYPE MAP_InitOutputType
! =======================
! =========  MAP_ContinuousStateType  =======
  TYPE, BIND(C) :: MAP_ContinuousStateType_C
    TYPE( MAP_ContState_C ) :: object
    REAL(KIND=C_DOUBLE) :: dummy 
  END TYPE MAP_ContinuousStateType_C
  TYPE, PUBLIC :: MAP_ContinuousStateType
    TYPE( c_ptr ) :: MAP_UserData = C_NULL_ptr
    TYPE( MAP_ContinuousStateType_C ) :: C_obj
    REAL(DbKi)  :: dummy      ! Remove this variable if you have continuous states [-]
  END TYPE MAP_ContinuousStateType
! =======================
! =========  MAP_DiscreteStateType  =======
  TYPE, BIND(C) :: MAP_DiscreteStateType_C
    TYPE( MAP_DiscState_C ) :: object
    REAL(KIND=C_DOUBLE) :: dummy 
  END TYPE MAP_DiscreteStateType_C
  TYPE, PUBLIC :: MAP_DiscreteStateType
    TYPE( c_ptr ) :: MAP_UserData = C_NULL_ptr
    TYPE( MAP_DiscreteStateType_C ) :: C_obj
    REAL(DbKi)  :: dummy      ! Remove this variable if you have discrete states [-]
  END TYPE MAP_DiscreteStateType
! =======================
! =========  MAP_OtherStateType  =======
  TYPE, BIND(C) :: MAP_OtherStateType_C
    TYPE( MAP_OtherState_C ) :: object
    TYPE(C_ptr) :: H = C_NULL_PTR 
    INTEGER(C_int) :: H_Len = 0 
    TYPE(C_ptr) :: V = C_NULL_PTR 
    INTEGER(C_int) :: V_Len = 0 
    TYPE(C_ptr) :: Ha = C_NULL_PTR 
    INTEGER(C_int) :: Ha_Len = 0 
    TYPE(C_ptr) :: Va = C_NULL_PTR 
    INTEGER(C_int) :: Va_Len = 0 
    TYPE(C_ptr) :: x = C_NULL_PTR 
    INTEGER(C_int) :: x_Len = 0 
    TYPE(C_ptr) :: y = C_NULL_PTR 
    INTEGER(C_int) :: y_Len = 0 
    TYPE(C_ptr) :: z = C_NULL_PTR 
    INTEGER(C_int) :: z_Len = 0 
    TYPE(C_ptr) :: xa = C_NULL_PTR 
    INTEGER(C_int) :: xa_Len = 0 
    TYPE(C_ptr) :: ya = C_NULL_PTR 
    INTEGER(C_int) :: ya_Len = 0 
    TYPE(C_ptr) :: za = C_NULL_PTR 
    INTEGER(C_int) :: za_Len = 0 
    TYPE(C_ptr) :: Fx_connect = C_NULL_PTR 
    INTEGER(C_int) :: Fx_connect_Len = 0 
    TYPE(C_ptr) :: Fy_connect = C_NULL_PTR 
    INTEGER(C_int) :: Fy_connect_Len = 0 
    TYPE(C_ptr) :: Fz_connect = C_NULL_PTR 
    INTEGER(C_int) :: Fz_connect_Len = 0 
    TYPE(C_ptr) :: Fx_anchor = C_NULL_PTR 
    INTEGER(C_int) :: Fx_anchor_Len = 0 
    TYPE(C_ptr) :: Fy_anchor = C_NULL_PTR 
    INTEGER(C_int) :: Fy_anchor_Len = 0 
    TYPE(C_ptr) :: Fz_anchor = C_NULL_PTR 
    INTEGER(C_int) :: Fz_anchor_Len = 0 
  END TYPE MAP_OtherStateType_C
  TYPE, PUBLIC :: MAP_OtherStateType
    TYPE( c_ptr ) :: MAP_UserData = C_NULL_ptr
    TYPE( MAP_OtherStateType_C ) :: C_obj
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: H => NULL()      ! horizontal line force [[N]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: V => NULL()      ! Vertical line force [[N]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: Ha => NULL()      ! horizontal line force at anchor [[N]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: Va => NULL()      ! Vertical line force at anchor [[N]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: x => NULL()      ! x fairlead line position [[m]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: y => NULL()      ! y fairlead line position [[m]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: z => NULL()      ! z fairlead line position [[m]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: xa => NULL()      ! x fairlead line position at anchor [[m]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: ya => NULL()      ! y fairlead line position at anchor [[m]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: za => NULL()      ! z fairlead line position at anchor [[m]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: Fx_connect => NULL()      ! horizontal x line force at connect node [[N]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: Fy_connect => NULL()      ! horizontal y line force at connect node [[N]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: Fz_connect => NULL()      ! vertical z line force at connect node [[N]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: Fx_anchor => NULL()      ! horizontal x line force at connect node [[N]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: Fy_anchor => NULL()      ! horizontal y line force at connect node [[N]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: Fz_anchor => NULL()      ! vertical z line force at connect node [[N]]
  END TYPE MAP_OtherStateType
! =======================
! =========  MAP_ConstraintStateType  =======
  TYPE, BIND(C) :: MAP_ConstraintStateType_C
    TYPE( MAP_ConstrState_C ) :: object
    TYPE(C_ptr) :: H = C_NULL_PTR 
    INTEGER(C_int) :: H_Len = 0 
    TYPE(C_ptr) :: V = C_NULL_PTR 
    INTEGER(C_int) :: V_Len = 0 
    TYPE(C_ptr) :: x = C_NULL_PTR 
    INTEGER(C_int) :: x_Len = 0 
    TYPE(C_ptr) :: y = C_NULL_PTR 
    INTEGER(C_int) :: y_Len = 0 
    TYPE(C_ptr) :: z = C_NULL_PTR 
    INTEGER(C_int) :: z_Len = 0 
  END TYPE MAP_ConstraintStateType_C
  TYPE, PUBLIC :: MAP_ConstraintStateType
    TYPE( c_ptr ) :: MAP_UserData = C_NULL_ptr
    TYPE( MAP_ConstraintStateType_C ) :: C_obj
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: H => NULL()      ! horizontal line force [[N]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: V => NULL()      ! Vertical line force [[N]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: x => NULL()      ! fairlead x displacement [[m]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: y => NULL()      ! fairlead y displacement [[m]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: z => NULL()      ! fairlead z displacement [[m]]
  END TYPE MAP_ConstraintStateType
! =======================
! =========  MAP_ParameterType  =======
  TYPE, BIND(C) :: MAP_ParameterType_C
    TYPE( MAP_Param_C ) :: object
    REAL(KIND=C_DOUBLE) :: g 
    REAL(KIND=C_DOUBLE) :: depth 
    REAL(KIND=C_DOUBLE) :: rhoSea 
  END TYPE MAP_ParameterType_C
  TYPE, PUBLIC :: MAP_ParameterType
    TYPE( c_ptr ) :: MAP_UserData = C_NULL_ptr
    TYPE( MAP_ParameterType_C ) :: C_obj
    REAL(DbKi)  :: g      ! gravitational constant [[kg/m^2]]
    REAL(DbKi)  :: depth      ! distance to seabed [[m]]
    REAL(DbKi)  :: rhoSea      ! density of seawater [[m]]
  END TYPE MAP_ParameterType
! =======================
! =========  MAP_InputType  =======
  TYPE, BIND(C) :: MAP_InputType_C
    TYPE( MAP_Input_C ) :: object
    TYPE(C_ptr) :: x = C_NULL_PTR 
    INTEGER(C_int) :: x_Len = 0 
    TYPE(C_ptr) :: y = C_NULL_PTR 
    INTEGER(C_int) :: y_Len = 0 
    TYPE(C_ptr) :: z = C_NULL_PTR 
    INTEGER(C_int) :: z_Len = 0 
  END TYPE MAP_InputType_C
  TYPE, PUBLIC :: MAP_InputType
    TYPE( c_ptr ) :: MAP_UserData = C_NULL_ptr
    TYPE( MAP_InputType_C ) :: C_obj
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: x => NULL()      ! fairlead x displacement [[m]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: y => NULL()      ! fairlead y displacement [[m]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: z => NULL()      ! fairlead z displacement [[m]]
    TYPE(MeshType)  :: PtFairDisplacement      ! position of each fairlead in X,Y,Z [[m]]
  END TYPE MAP_InputType
! =======================
! =========  MAP_OutputType  =======
  TYPE, BIND(C) :: MAP_OutputType_C
    TYPE( MAP_Output_C ) :: object
    TYPE(C_ptr) :: Fx = C_NULL_PTR 
    INTEGER(C_int) :: Fx_Len = 0 
    TYPE(C_ptr) :: Fy = C_NULL_PTR 
    INTEGER(C_int) :: Fy_Len = 0 
    TYPE(C_ptr) :: Fz = C_NULL_PTR 
    INTEGER(C_int) :: Fz_Len = 0 
    TYPE(C_ptr) :: wrtOutput = C_NULL_PTR 
    INTEGER(C_int) :: wrtOutput_Len = 0 
  END TYPE MAP_OutputType_C
  TYPE, PUBLIC :: MAP_OutputType
    TYPE( c_ptr ) :: MAP_UserData = C_NULL_ptr
    TYPE( MAP_OutputType_C ) :: C_obj
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: Fx => NULL()      ! horizontal line force [[N]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: Fy => NULL()      ! Vertical line force [[N]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: Fz => NULL()      ! horizontal line force at anchor [[N]]
    REAL(KIND=C_DOUBLE) , DIMENSION(:), POINTER  :: wrtOutput => NULL()      ! outpur vector []
    TYPE(MeshType)  :: ptFairleadLoad      ! point mesh for forces in X,Y,Z [[N]]
  END TYPE MAP_OutputType
! =======================

  INTERFACE
     SUBROUTINE MAP_F2C_OtherState_H( Object, arr, len) BIND(C,name='MAP_F2C_OtherState_H_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_OtherStateType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_OtherState_H
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_OtherState_V( Object, arr, len) BIND(C,name='MAP_F2C_OtherState_V_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_OtherStateType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_OtherState_V
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_OtherState_Ha( Object, arr, len) BIND(C,name='MAP_F2C_OtherState_Ha_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_OtherStateType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_OtherState_Ha
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_OtherState_Va( Object, arr, len) BIND(C,name='MAP_F2C_OtherState_Va_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_OtherStateType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_OtherState_Va
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_OtherState_x( Object, arr, len) BIND(C,name='MAP_F2C_OtherState_x_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_OtherStateType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_OtherState_x
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_OtherState_y( Object, arr, len) BIND(C,name='MAP_F2C_OtherState_y_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_OtherStateType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_OtherState_y
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_OtherState_z( Object, arr, len) BIND(C,name='MAP_F2C_OtherState_z_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_OtherStateType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_OtherState_z
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_OtherState_xa( Object, arr, len) BIND(C,name='MAP_F2C_OtherState_xa_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_OtherStateType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_OtherState_xa
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_OtherState_ya( Object, arr, len) BIND(C,name='MAP_F2C_OtherState_ya_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_OtherStateType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_OtherState_ya
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_OtherState_za( Object, arr, len) BIND(C,name='MAP_F2C_OtherState_za_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_OtherStateType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_OtherState_za
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_OtherState_Fx_connect( Object, arr, len) BIND(C,name='MAP_F2C_OtherState_Fx_connect_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_OtherStateType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_OtherState_Fx_connect
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_OtherState_Fy_connect( Object, arr, len) BIND(C,name='MAP_F2C_OtherState_Fy_connect_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_OtherStateType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_OtherState_Fy_connect
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_OtherState_Fz_connect( Object, arr, len) BIND(C,name='MAP_F2C_OtherState_Fz_connect_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_OtherStateType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_OtherState_Fz_connect
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_OtherState_Fx_anchor( Object, arr, len) BIND(C,name='MAP_F2C_OtherState_Fx_anchor_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_OtherStateType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_OtherState_Fx_anchor
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_OtherState_Fy_anchor( Object, arr, len) BIND(C,name='MAP_F2C_OtherState_Fy_anchor_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_OtherStateType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_OtherState_Fy_anchor
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_OtherState_Fz_anchor( Object, arr, len) BIND(C,name='MAP_F2C_OtherState_Fz_anchor_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_OtherStateType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_OtherState_Fz_anchor
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_ConstrState_H( Object, arr, len) BIND(C,name='MAP_F2C_ConstrState_H_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_ConstraintStateType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_ConstrState_H
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_ConstrState_V( Object, arr, len) BIND(C,name='MAP_F2C_ConstrState_V_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_ConstraintStateType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_ConstrState_V
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_ConstrState_x( Object, arr, len) BIND(C,name='MAP_F2C_ConstrState_x_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_ConstraintStateType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_ConstrState_x
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_ConstrState_y( Object, arr, len) BIND(C,name='MAP_F2C_ConstrState_y_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_ConstraintStateType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_ConstrState_y
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_ConstrState_z( Object, arr, len) BIND(C,name='MAP_F2C_ConstrState_z_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_ConstraintStateType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_ConstrState_z
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_Input_x( Object, arr, len) BIND(C,name='MAP_F2C_Input_x_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_InputType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_Input_x
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_Input_y( Object, arr, len) BIND(C,name='MAP_F2C_Input_y_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_InputType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_Input_y
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_Input_z( Object, arr, len) BIND(C,name='MAP_F2C_Input_z_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_InputType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_Input_z
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_Output_Fx( Object, arr, len) BIND(C,name='MAP_F2C_Output_Fx_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_OutputType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_Output_Fx
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_Output_Fy( Object, arr, len) BIND(C,name='MAP_F2C_Output_Fy_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_OutputType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_Output_Fy
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_Output_Fz( Object, arr, len) BIND(C,name='MAP_F2C_Output_Fz_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_OutputType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_Output_Fz
  END INTERFACE

  INTERFACE
     SUBROUTINE MAP_F2C_Output_wrtOutput( Object, arr, len) BIND(C,name='MAP_F2C_Output_wrtOutput_C') 
       IMPORT
       IMPLICIT NONE
       TYPE( MAP_OutputType_C ) Object
       REAL(KIND=C_DOUBLE), DIMENSION(*) :: arr
       INTEGER(KIND=C_INT), VALUE :: len
     END SUBROUTINE MAP_F2C_Output_wrtOutput
  END INTERFACE
CONTAINS
  SUBROUTINE MAP_F2C_CopyInitInput( InitInputData, ErrStat, ErrMsg )
    TYPE(MAP_initinputtype), INTENT(INOUT) :: InitInputData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local 
    INTEGER(IntKi)                   :: i,i1,i2,i3,i4,i5,j,k
    REAL(KIND=C_DOUBLE) ,ALLOCATABLE :: c_dbl_value(:)
    REAL(KIND=C_DOUBLE) ,POINTER     :: dbl_arr(:)
    REAL(KIND=C_FLOAT)  ,ALLOCATABLE :: c_float_value(:)
    REAL(KIND=C_FLOAT)  ,POINTER     :: float_arr(:)
    INTEGER(KIND=C_INT) ,ALLOCATABLE :: c_int_value(:)
    INTEGER(KIND=C_INT) ,POINTER     :: int_arr(:)
    LOGICAL(KIND=C_BOOL),ALLOCATABLE :: c_bool_value(:)
    LOGICAL(KIND=C_BOOL),POINTER     :: bool_arr(:)
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""
    InitInputData%C_obj%gravity = InitInputData%gravity
    InitInputData%C_obj%seaDensity = InitInputData%seaDensity
    InitInputData%C_obj%depth = InitInputData%depth
 END SUBROUTINE MAP_F2C_CopyInitInput

  SUBROUTINE MAP_C2F_CopyInitInput( InitInputData, ErrStat, ErrMsg )
    TYPE(MAP_initinputtype), INTENT(INOUT) :: InitInputData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local 
    INTEGER(IntKi)                   :: i,i1,i2,i3,i4,i5,j,k
    REAL(KIND=C_DOUBLE) ,ALLOCATABLE :: c_dbl_value(:)
    REAL(KIND=C_DOUBLE) ,POINTER     :: dbl_arr(:)
    REAL(KIND=C_FLOAT)  ,ALLOCATABLE :: c_float_value(:)
    REAL(KIND=C_FLOAT)  ,POINTER     :: float_arr(:)
    INTEGER(KIND=C_INT) ,ALLOCATABLE :: c_int_value(:)
    INTEGER(KIND=C_INT) ,POINTER     :: int_arr(:)
    LOGICAL(KIND=C_BOOL),ALLOCATABLE :: c_bool_value(:)
    LOGICAL(KIND=C_BOOL),POINTER     :: bool_arr(:)
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""
    InitInputData%gravity = InitInputData%C_obj%gravity
    InitInputData%seaDensity = InitInputData%C_obj%seaDensity
    InitInputData%depth = InitInputData%C_obj%depth
 END SUBROUTINE MAP_C2F_CopyInitInput

 SUBROUTINE MAP_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MAP_initinputtype), INTENT(INOUT) :: SrcInitInputData
   TYPE(MAP_initinputtype), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstInitInputData%gravity = SrcInitInputData%gravity
   DstInitInputData%seaDensity = SrcInitInputData%seaDensity
   DstInitInputData%depth = SrcInitInputData%depth
   DstInitInputData%fileName = SrcInitInputData%fileName
   DstInitInputData%summaryFileName = SrcInitInputData%summaryFileName
   DstInitInputData%libraryInputLine = SrcInitInputData%libraryInputLine
   DstInitInputData%nodeInputLine = SrcInitInputData%nodeInputLine
   DstInitInputData%elementInputLine = SrcInitInputData%elementInputLine
   DstInitInputData%optionInputLine = SrcInitInputData%optionInputLine
 END SUBROUTINE MAP_CopyInitInput

 SUBROUTINE MAP_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(MAP_initinputtype), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE MAP_DestroyInitInput

 SUBROUTINE MAP_PackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MAP_initinputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz   = Db_BufSz   + 1  ! gravity
  Db_BufSz   = Db_BufSz   + 1  ! seaDensity
  Db_BufSz   = Db_BufSz   + 1  ! depth
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%gravity )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%seaDensity )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%depth )
  Db_Xferred   = Db_Xferred   + 1
 END SUBROUTINE MAP_PackInitInput

 SUBROUTINE MAP_UnPackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MAP_initinputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%gravity = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%seaDensity = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%depth = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MAP_UnPackInitInput

  SUBROUTINE MAP_F2C_CopyInitOutput( InitOutputData, ErrStat, ErrMsg )
    TYPE(MAP_initoutputtype), INTENT(INOUT) :: InitOutputData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local 
    INTEGER(IntKi)                   :: i,i1,i2,i3,i4,i5,j,k
    REAL(KIND=C_DOUBLE) ,ALLOCATABLE :: c_dbl_value(:)
    REAL(KIND=C_DOUBLE) ,POINTER     :: dbl_arr(:)
    REAL(KIND=C_FLOAT)  ,ALLOCATABLE :: c_float_value(:)
    REAL(KIND=C_FLOAT)  ,POINTER     :: float_arr(:)
    INTEGER(KIND=C_INT) ,ALLOCATABLE :: c_int_value(:)
    INTEGER(KIND=C_INT) ,POINTER     :: int_arr(:)
    LOGICAL(KIND=C_BOOL),ALLOCATABLE :: c_bool_value(:)
    LOGICAL(KIND=C_BOOL),POINTER     :: bool_arr(:)
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""
 END SUBROUTINE MAP_F2C_CopyInitOutput

  SUBROUTINE MAP_C2F_CopyInitOutput( InitOutputData, ErrStat, ErrMsg )
    TYPE(MAP_initoutputtype), INTENT(INOUT) :: InitOutputData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local 
    INTEGER(IntKi)                   :: i,i1,i2,i3,i4,i5,j,k
    REAL(KIND=C_DOUBLE) ,ALLOCATABLE :: c_dbl_value(:)
    REAL(KIND=C_DOUBLE) ,POINTER     :: dbl_arr(:)
    REAL(KIND=C_FLOAT)  ,ALLOCATABLE :: c_float_value(:)
    REAL(KIND=C_FLOAT)  ,POINTER     :: float_arr(:)
    INTEGER(KIND=C_INT) ,ALLOCATABLE :: c_int_value(:)
    INTEGER(KIND=C_INT) ,POINTER     :: int_arr(:)
    LOGICAL(KIND=C_BOOL),ALLOCATABLE :: c_bool_value(:)
    LOGICAL(KIND=C_BOOL),POINTER     :: bool_arr(:)
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""
 END SUBROUTINE MAP_C2F_CopyInitOutput

 SUBROUTINE MAP_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MAP_initoutputtype), INTENT(INOUT) :: SrcInitOutputData
   TYPE(MAP_initoutputtype), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstInitOutputData%progName = SrcInitOutputData%progName
   DstInitOutputData%version = SrcInitOutputData%version
   DstInitOutputData%compilingData = SrcInitOutputData%compilingData
IF (ALLOCATED(SrcInitOutputData%writeOutputHdr)) THEN
   i1_l = LBOUND(SrcInitOutputData%writeOutputHdr,1)
   i1_u = UBOUND(SrcInitOutputData%writeOutputHdr,1)
   IF (.NOT. ALLOCATED(DstInitOutputData%writeOutputHdr)) THEN 
      ALLOCATE(DstInitOutputData%writeOutputHdr(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MAP_CopyInitOutput: Error allocating DstInitOutputData%writeOutputHdr.'
         RETURN
      END IF
   END IF
   DstInitOutputData%writeOutputHdr = SrcInitOutputData%writeOutputHdr
ENDIF
IF (ALLOCATED(SrcInitOutputData%writeOutputUnt)) THEN
   i1_l = LBOUND(SrcInitOutputData%writeOutputUnt,1)
   i1_u = UBOUND(SrcInitOutputData%writeOutputUnt,1)
   IF (.NOT. ALLOCATED(DstInitOutputData%writeOutputUnt)) THEN 
      ALLOCATE(DstInitOutputData%writeOutputUnt(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MAP_CopyInitOutput: Error allocating DstInitOutputData%writeOutputUnt.'
         RETURN
      END IF
   END IF
   DstInitOutputData%writeOutputUnt = SrcInitOutputData%writeOutputUnt
ENDIF
      CALL NWTC_Library_Copyprogdesc( SrcInitOutputData%Ver, DstInitOutputData%Ver, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE MAP_CopyInitOutput

 SUBROUTINE MAP_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(MAP_initoutputtype), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE MAP_DestroyInitOutput

 SUBROUTINE MAP_PackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MAP_initoutputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_Ver_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Ver_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Ver_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, InData%Ver, ErrStat, ErrMsg, .TRUE. ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_Ver_Buf  ) ! Ver
  IF(ALLOCATED(Db_Ver_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_Ver_Buf  ) ! Ver
  IF(ALLOCATED(Int_Ver_Buf))Int_BufSz = Int_BufSz + SIZE( Int_Ver_Buf ) ! Ver
  IF(ALLOCATED(Re_Ver_Buf))  DEALLOCATE(Re_Ver_Buf)
  IF(ALLOCATED(Db_Ver_Buf))  DEALLOCATE(Db_Ver_Buf)
  IF(ALLOCATED(Int_Ver_Buf)) DEALLOCATE(Int_Ver_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, InData%Ver, ErrStat, ErrMsg, OnlySize ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Ver_Buf)-1 ) = Re_Ver_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Db_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Ver_Buf)-1 ) = Db_Ver_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Int_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Ver_Buf)-1 ) = Int_Ver_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_Ver_Buf)
  ENDIF
  IF( ALLOCATED(Re_Ver_Buf) )  DEALLOCATE(Re_Ver_Buf)
  IF( ALLOCATED(Db_Ver_Buf) )  DEALLOCATE(Db_Ver_Buf)
  IF( ALLOCATED(Int_Ver_Buf) ) DEALLOCATE(Int_Ver_Buf)
 END SUBROUTINE MAP_PackInitOutput

 SUBROUTINE MAP_UnPackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MAP_initoutputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_Ver_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Ver_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Ver_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call NWTC_Library_Packprogdesc to get correctly sized buffers for unpacking
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, OutData%Ver, ErrStat, ErrMsg, .TRUE. ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) THEN
    Re_Ver_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Ver_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Db_Ver_Buf)) THEN
    Db_Ver_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Ver_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Int_Ver_Buf)) THEN
    Int_Ver_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Ver_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_Ver_Buf)
  ENDIF
  CALL NWTC_Library_UnPackprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, OutData%Ver, ErrStat, ErrMsg ) ! Ver 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MAP_UnPackInitOutput

  SUBROUTINE MAP_F2C_CopyContState( ContStateData, ErrStat, ErrMsg )
    TYPE(MAP_continuousstatetype), INTENT(INOUT) :: ContStateData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local 
    INTEGER(IntKi)                   :: i,i1,i2,i3,i4,i5,j,k
    REAL(KIND=C_DOUBLE) ,ALLOCATABLE :: c_dbl_value(:)
    REAL(KIND=C_DOUBLE) ,POINTER     :: dbl_arr(:)
    REAL(KIND=C_FLOAT)  ,ALLOCATABLE :: c_float_value(:)
    REAL(KIND=C_FLOAT)  ,POINTER     :: float_arr(:)
    INTEGER(KIND=C_INT) ,ALLOCATABLE :: c_int_value(:)
    INTEGER(KIND=C_INT) ,POINTER     :: int_arr(:)
    LOGICAL(KIND=C_BOOL),ALLOCATABLE :: c_bool_value(:)
    LOGICAL(KIND=C_BOOL),POINTER     :: bool_arr(:)
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""
    ContStateData%C_obj%dummy = ContStateData%dummy
 END SUBROUTINE MAP_F2C_CopyContState

  SUBROUTINE MAP_C2F_CopyContState( ContStateData, ErrStat, ErrMsg )
    TYPE(MAP_continuousstatetype), INTENT(INOUT) :: ContStateData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local 
    INTEGER(IntKi)                   :: i,i1,i2,i3,i4,i5,j,k
    REAL(KIND=C_DOUBLE) ,ALLOCATABLE :: c_dbl_value(:)
    REAL(KIND=C_DOUBLE) ,POINTER     :: dbl_arr(:)
    REAL(KIND=C_FLOAT)  ,ALLOCATABLE :: c_float_value(:)
    REAL(KIND=C_FLOAT)  ,POINTER     :: float_arr(:)
    INTEGER(KIND=C_INT) ,ALLOCATABLE :: c_int_value(:)
    INTEGER(KIND=C_INT) ,POINTER     :: int_arr(:)
    LOGICAL(KIND=C_BOOL),ALLOCATABLE :: c_bool_value(:)
    LOGICAL(KIND=C_BOOL),POINTER     :: bool_arr(:)
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""
    ContStateData%dummy = ContStateData%C_obj%dummy
 END SUBROUTINE MAP_C2F_CopyContState

 SUBROUTINE MAP_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MAP_continuousstatetype), INTENT(INOUT) :: SrcContStateData
   TYPE(MAP_continuousstatetype), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstContStateData%dummy = SrcContStateData%dummy
 END SUBROUTINE MAP_CopyContState

 SUBROUTINE MAP_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(MAP_continuousstatetype), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE MAP_DestroyContState

 SUBROUTINE MAP_PackContState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MAP_continuousstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz   = Db_BufSz   + 1  ! dummy
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%dummy )
  Db_Xferred   = Db_Xferred   + 1
 END SUBROUTINE MAP_PackContState

 SUBROUTINE MAP_UnPackContState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MAP_continuousstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%dummy = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MAP_UnPackContState

  SUBROUTINE MAP_F2C_CopyDiscState( DiscStateData, ErrStat, ErrMsg )
    TYPE(MAP_discretestatetype), INTENT(INOUT) :: DiscStateData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local 
    INTEGER(IntKi)                   :: i,i1,i2,i3,i4,i5,j,k
    REAL(KIND=C_DOUBLE) ,ALLOCATABLE :: c_dbl_value(:)
    REAL(KIND=C_DOUBLE) ,POINTER     :: dbl_arr(:)
    REAL(KIND=C_FLOAT)  ,ALLOCATABLE :: c_float_value(:)
    REAL(KIND=C_FLOAT)  ,POINTER     :: float_arr(:)
    INTEGER(KIND=C_INT) ,ALLOCATABLE :: c_int_value(:)
    INTEGER(KIND=C_INT) ,POINTER     :: int_arr(:)
    LOGICAL(KIND=C_BOOL),ALLOCATABLE :: c_bool_value(:)
    LOGICAL(KIND=C_BOOL),POINTER     :: bool_arr(:)
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""
    DiscStateData%C_obj%dummy = DiscStateData%dummy
 END SUBROUTINE MAP_F2C_CopyDiscState

  SUBROUTINE MAP_C2F_CopyDiscState( DiscStateData, ErrStat, ErrMsg )
    TYPE(MAP_discretestatetype), INTENT(INOUT) :: DiscStateData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local 
    INTEGER(IntKi)                   :: i,i1,i2,i3,i4,i5,j,k
    REAL(KIND=C_DOUBLE) ,ALLOCATABLE :: c_dbl_value(:)
    REAL(KIND=C_DOUBLE) ,POINTER     :: dbl_arr(:)
    REAL(KIND=C_FLOAT)  ,ALLOCATABLE :: c_float_value(:)
    REAL(KIND=C_FLOAT)  ,POINTER     :: float_arr(:)
    INTEGER(KIND=C_INT) ,ALLOCATABLE :: c_int_value(:)
    INTEGER(KIND=C_INT) ,POINTER     :: int_arr(:)
    LOGICAL(KIND=C_BOOL),ALLOCATABLE :: c_bool_value(:)
    LOGICAL(KIND=C_BOOL),POINTER     :: bool_arr(:)
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""
    DiscStateData%dummy = DiscStateData%C_obj%dummy
 END SUBROUTINE MAP_C2F_CopyDiscState

 SUBROUTINE MAP_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MAP_discretestatetype), INTENT(INOUT) :: SrcDiscStateData
   TYPE(MAP_discretestatetype), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstDiscStateData%dummy = SrcDiscStateData%dummy
 END SUBROUTINE MAP_CopyDiscState

 SUBROUTINE MAP_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(MAP_discretestatetype), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE MAP_DestroyDiscState

 SUBROUTINE MAP_PackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MAP_discretestatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz   = Db_BufSz   + 1  ! dummy
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%dummy )
  Db_Xferred   = Db_Xferred   + 1
 END SUBROUTINE MAP_PackDiscState

 SUBROUTINE MAP_UnPackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MAP_discretestatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%dummy = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MAP_UnPackDiscState

  SUBROUTINE MAP_F2C_CopyOtherState( OtherStateData, ErrStat, ErrMsg )
    TYPE(MAP_otherstatetype), INTENT(INOUT) :: OtherStateData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local 
    INTEGER(IntKi)                   :: i,i1,i2,i3,i4,i5,j,k
    REAL(KIND=C_DOUBLE) ,ALLOCATABLE :: c_dbl_value(:)
    REAL(KIND=C_DOUBLE) ,POINTER     :: dbl_arr(:)
    REAL(KIND=C_FLOAT)  ,ALLOCATABLE :: c_float_value(:)
    REAL(KIND=C_FLOAT)  ,POINTER     :: float_arr(:)
    INTEGER(KIND=C_INT) ,ALLOCATABLE :: c_int_value(:)
    INTEGER(KIND=C_INT) ,POINTER     :: int_arr(:)
    LOGICAL(KIND=C_BOOL),ALLOCATABLE :: c_bool_value(:)
    LOGICAL(KIND=C_BOOL),POINTER     :: bool_arr(:)
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""

    ! -- H OtherState Data fields
    IF ( ASSOCIATED( OtherStateData%H ) ) THEN
       ALLOCATE( c_dbl_value(OtherStateData%C_obj%H_Len) )
       DO i = 1 , OtherStateData%C_obj%H_Len
          c_dbl_value(i) = OtherStateData%H(i)
       END DO
       CALL MAP_F2C_OtherState_H( OtherStateData%C_obj, c_dbl_value, OtherStateData%C_obj%H_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- V OtherState Data fields
    IF ( ASSOCIATED( OtherStateData%V ) ) THEN
       ALLOCATE( c_dbl_value(OtherStateData%C_obj%V_Len) )
       DO i = 1 , OtherStateData%C_obj%V_Len
          c_dbl_value(i) = OtherStateData%V(i)
       END DO
       CALL MAP_F2C_OtherState_V( OtherStateData%C_obj, c_dbl_value, OtherStateData%C_obj%V_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- Ha OtherState Data fields
    IF ( ASSOCIATED( OtherStateData%Ha ) ) THEN
       ALLOCATE( c_dbl_value(OtherStateData%C_obj%Ha_Len) )
       DO i = 1 , OtherStateData%C_obj%Ha_Len
          c_dbl_value(i) = OtherStateData%Ha(i)
       END DO
       CALL MAP_F2C_OtherState_Ha( OtherStateData%C_obj, c_dbl_value, OtherStateData%C_obj%Ha_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- Va OtherState Data fields
    IF ( ASSOCIATED( OtherStateData%Va ) ) THEN
       ALLOCATE( c_dbl_value(OtherStateData%C_obj%Va_Len) )
       DO i = 1 , OtherStateData%C_obj%Va_Len
          c_dbl_value(i) = OtherStateData%Va(i)
       END DO
       CALL MAP_F2C_OtherState_Va( OtherStateData%C_obj, c_dbl_value, OtherStateData%C_obj%Va_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- x OtherState Data fields
    IF ( ASSOCIATED( OtherStateData%x ) ) THEN
       ALLOCATE( c_dbl_value(OtherStateData%C_obj%x_Len) )
       DO i = 1 , OtherStateData%C_obj%x_Len
          c_dbl_value(i) = OtherStateData%x(i)
       END DO
       CALL MAP_F2C_OtherState_x( OtherStateData%C_obj, c_dbl_value, OtherStateData%C_obj%x_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- y OtherState Data fields
    IF ( ASSOCIATED( OtherStateData%y ) ) THEN
       ALLOCATE( c_dbl_value(OtherStateData%C_obj%y_Len) )
       DO i = 1 , OtherStateData%C_obj%y_Len
          c_dbl_value(i) = OtherStateData%y(i)
       END DO
       CALL MAP_F2C_OtherState_y( OtherStateData%C_obj, c_dbl_value, OtherStateData%C_obj%y_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- z OtherState Data fields
    IF ( ASSOCIATED( OtherStateData%z ) ) THEN
       ALLOCATE( c_dbl_value(OtherStateData%C_obj%z_Len) )
       DO i = 1 , OtherStateData%C_obj%z_Len
          c_dbl_value(i) = OtherStateData%z(i)
       END DO
       CALL MAP_F2C_OtherState_z( OtherStateData%C_obj, c_dbl_value, OtherStateData%C_obj%z_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- xa OtherState Data fields
    IF ( ASSOCIATED( OtherStateData%xa ) ) THEN
       ALLOCATE( c_dbl_value(OtherStateData%C_obj%xa_Len) )
       DO i = 1 , OtherStateData%C_obj%xa_Len
          c_dbl_value(i) = OtherStateData%xa(i)
       END DO
       CALL MAP_F2C_OtherState_xa( OtherStateData%C_obj, c_dbl_value, OtherStateData%C_obj%xa_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- ya OtherState Data fields
    IF ( ASSOCIATED( OtherStateData%ya ) ) THEN
       ALLOCATE( c_dbl_value(OtherStateData%C_obj%ya_Len) )
       DO i = 1 , OtherStateData%C_obj%ya_Len
          c_dbl_value(i) = OtherStateData%ya(i)
       END DO
       CALL MAP_F2C_OtherState_ya( OtherStateData%C_obj, c_dbl_value, OtherStateData%C_obj%ya_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- za OtherState Data fields
    IF ( ASSOCIATED( OtherStateData%za ) ) THEN
       ALLOCATE( c_dbl_value(OtherStateData%C_obj%za_Len) )
       DO i = 1 , OtherStateData%C_obj%za_Len
          c_dbl_value(i) = OtherStateData%za(i)
       END DO
       CALL MAP_F2C_OtherState_za( OtherStateData%C_obj, c_dbl_value, OtherStateData%C_obj%za_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- Fx_connect OtherState Data fields
    IF ( ASSOCIATED( OtherStateData%Fx_connect ) ) THEN
       ALLOCATE( c_dbl_value(OtherStateData%C_obj%Fx_connect_Len) )
       DO i = 1 , OtherStateData%C_obj%Fx_connect_Len
          c_dbl_value(i) = OtherStateData%Fx_connect(i)
       END DO
       CALL MAP_F2C_OtherState_Fx_connect( OtherStateData%C_obj, c_dbl_value, OtherStateData%C_obj%Fx_connect_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- Fy_connect OtherState Data fields
    IF ( ASSOCIATED( OtherStateData%Fy_connect ) ) THEN
       ALLOCATE( c_dbl_value(OtherStateData%C_obj%Fy_connect_Len) )
       DO i = 1 , OtherStateData%C_obj%Fy_connect_Len
          c_dbl_value(i) = OtherStateData%Fy_connect(i)
       END DO
       CALL MAP_F2C_OtherState_Fy_connect( OtherStateData%C_obj, c_dbl_value, OtherStateData%C_obj%Fy_connect_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- Fz_connect OtherState Data fields
    IF ( ASSOCIATED( OtherStateData%Fz_connect ) ) THEN
       ALLOCATE( c_dbl_value(OtherStateData%C_obj%Fz_connect_Len) )
       DO i = 1 , OtherStateData%C_obj%Fz_connect_Len
          c_dbl_value(i) = OtherStateData%Fz_connect(i)
       END DO
       CALL MAP_F2C_OtherState_Fz_connect( OtherStateData%C_obj, c_dbl_value, OtherStateData%C_obj%Fz_connect_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- Fx_anchor OtherState Data fields
    IF ( ASSOCIATED( OtherStateData%Fx_anchor ) ) THEN
       ALLOCATE( c_dbl_value(OtherStateData%C_obj%Fx_anchor_Len) )
       DO i = 1 , OtherStateData%C_obj%Fx_anchor_Len
          c_dbl_value(i) = OtherStateData%Fx_anchor(i)
       END DO
       CALL MAP_F2C_OtherState_Fx_anchor( OtherStateData%C_obj, c_dbl_value, OtherStateData%C_obj%Fx_anchor_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- Fy_anchor OtherState Data fields
    IF ( ASSOCIATED( OtherStateData%Fy_anchor ) ) THEN
       ALLOCATE( c_dbl_value(OtherStateData%C_obj%Fy_anchor_Len) )
       DO i = 1 , OtherStateData%C_obj%Fy_anchor_Len
          c_dbl_value(i) = OtherStateData%Fy_anchor(i)
       END DO
       CALL MAP_F2C_OtherState_Fy_anchor( OtherStateData%C_obj, c_dbl_value, OtherStateData%C_obj%Fy_anchor_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- Fz_anchor OtherState Data fields
    IF ( ASSOCIATED( OtherStateData%Fz_anchor ) ) THEN
       ALLOCATE( c_dbl_value(OtherStateData%C_obj%Fz_anchor_Len) )
       DO i = 1 , OtherStateData%C_obj%Fz_anchor_Len
          c_dbl_value(i) = OtherStateData%Fz_anchor(i)
       END DO
       CALL MAP_F2C_OtherState_Fz_anchor( OtherStateData%C_obj, c_dbl_value, OtherStateData%C_obj%Fz_anchor_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF
 END SUBROUTINE MAP_F2C_CopyOtherState

  SUBROUTINE MAP_C2F_CopyOtherState( OtherStateData, ErrStat, ErrMsg )
    TYPE(MAP_otherstatetype), INTENT(INOUT) :: OtherStateData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local 
    INTEGER(IntKi)                   :: i,i1,i2,i3,i4,i5,j,k
    REAL(KIND=C_DOUBLE) ,ALLOCATABLE :: c_dbl_value(:)
    REAL(KIND=C_DOUBLE) ,POINTER     :: dbl_arr(:)
    REAL(KIND=C_FLOAT)  ,ALLOCATABLE :: c_float_value(:)
    REAL(KIND=C_FLOAT)  ,POINTER     :: float_arr(:)
    INTEGER(KIND=C_INT) ,ALLOCATABLE :: c_int_value(:)
    INTEGER(KIND=C_INT) ,POINTER     :: int_arr(:)
    LOGICAL(KIND=C_BOOL),ALLOCATABLE :: c_bool_value(:)
    LOGICAL(KIND=C_BOOL),POINTER     :: bool_arr(:)
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""

    ! -- H OtherState Data fields
    IF ( ASSOCIATED( OtherStateData%H ) ) THEN
       CALL C_F_POINTER( OtherStateData%C_obj%H, dbl_arr, (/OtherStateData%C_obj%H_Len/) )
       DO i = 1, OtherStateData%C_obj%H_Len
          OtherStateData%H(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- V OtherState Data fields
    IF ( ASSOCIATED( OtherStateData%V ) ) THEN
       CALL C_F_POINTER( OtherStateData%C_obj%V, dbl_arr, (/OtherStateData%C_obj%V_Len/) )
       DO i = 1, OtherStateData%C_obj%V_Len
          OtherStateData%V(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- Ha OtherState Data fields
    IF ( ASSOCIATED( OtherStateData%Ha ) ) THEN
       CALL C_F_POINTER( OtherStateData%C_obj%Ha, dbl_arr, (/OtherStateData%C_obj%Ha_Len/) )
       DO i = 1, OtherStateData%C_obj%Ha_Len
          OtherStateData%Ha(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- Va OtherState Data fields
    IF ( ASSOCIATED( OtherStateData%Va ) ) THEN
       CALL C_F_POINTER( OtherStateData%C_obj%Va, dbl_arr, (/OtherStateData%C_obj%Va_Len/) )
       DO i = 1, OtherStateData%C_obj%Va_Len
          OtherStateData%Va(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- x OtherState Data fields
    IF ( ASSOCIATED( OtherStateData%x ) ) THEN
       CALL C_F_POINTER( OtherStateData%C_obj%x, dbl_arr, (/OtherStateData%C_obj%x_Len/) )
       DO i = 1, OtherStateData%C_obj%x_Len
          OtherStateData%x(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- y OtherState Data fields
    IF ( ASSOCIATED( OtherStateData%y ) ) THEN
       CALL C_F_POINTER( OtherStateData%C_obj%y, dbl_arr, (/OtherStateData%C_obj%y_Len/) )
       DO i = 1, OtherStateData%C_obj%y_Len
          OtherStateData%y(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- z OtherState Data fields
    IF ( ASSOCIATED( OtherStateData%z ) ) THEN
       CALL C_F_POINTER( OtherStateData%C_obj%z, dbl_arr, (/OtherStateData%C_obj%z_Len/) )
       DO i = 1, OtherStateData%C_obj%z_Len
          OtherStateData%z(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- xa OtherState Data fields
    IF ( ASSOCIATED( OtherStateData%xa ) ) THEN
       CALL C_F_POINTER( OtherStateData%C_obj%xa, dbl_arr, (/OtherStateData%C_obj%xa_Len/) )
       DO i = 1, OtherStateData%C_obj%xa_Len
          OtherStateData%xa(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- ya OtherState Data fields
    IF ( ASSOCIATED( OtherStateData%ya ) ) THEN
       CALL C_F_POINTER( OtherStateData%C_obj%ya, dbl_arr, (/OtherStateData%C_obj%ya_Len/) )
       DO i = 1, OtherStateData%C_obj%ya_Len
          OtherStateData%ya(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- za OtherState Data fields
    IF ( ASSOCIATED( OtherStateData%za ) ) THEN
       CALL C_F_POINTER( OtherStateData%C_obj%za, dbl_arr, (/OtherStateData%C_obj%za_Len/) )
       DO i = 1, OtherStateData%C_obj%za_Len
          OtherStateData%za(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- Fx_connect OtherState Data fields
    IF ( ASSOCIATED( OtherStateData%Fx_connect ) ) THEN
       CALL C_F_POINTER( OtherStateData%C_obj%Fx_connect, dbl_arr, (/OtherStateData%C_obj%Fx_connect_Len/) )
       DO i = 1, OtherStateData%C_obj%Fx_connect_Len
          OtherStateData%Fx_connect(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- Fy_connect OtherState Data fields
    IF ( ASSOCIATED( OtherStateData%Fy_connect ) ) THEN
       CALL C_F_POINTER( OtherStateData%C_obj%Fy_connect, dbl_arr, (/OtherStateData%C_obj%Fy_connect_Len/) )
       DO i = 1, OtherStateData%C_obj%Fy_connect_Len
          OtherStateData%Fy_connect(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- Fz_connect OtherState Data fields
    IF ( ASSOCIATED( OtherStateData%Fz_connect ) ) THEN
       CALL C_F_POINTER( OtherStateData%C_obj%Fz_connect, dbl_arr, (/OtherStateData%C_obj%Fz_connect_Len/) )
       DO i = 1, OtherStateData%C_obj%Fz_connect_Len
          OtherStateData%Fz_connect(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- Fx_anchor OtherState Data fields
    IF ( ASSOCIATED( OtherStateData%Fx_anchor ) ) THEN
       CALL C_F_POINTER( OtherStateData%C_obj%Fx_anchor, dbl_arr, (/OtherStateData%C_obj%Fx_anchor_Len/) )
       DO i = 1, OtherStateData%C_obj%Fx_anchor_Len
          OtherStateData%Fx_anchor(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- Fy_anchor OtherState Data fields
    IF ( ASSOCIATED( OtherStateData%Fy_anchor ) ) THEN
       CALL C_F_POINTER( OtherStateData%C_obj%Fy_anchor, dbl_arr, (/OtherStateData%C_obj%Fy_anchor_Len/) )
       DO i = 1, OtherStateData%C_obj%Fy_anchor_Len
          OtherStateData%Fy_anchor(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- Fz_anchor OtherState Data fields
    IF ( ASSOCIATED( OtherStateData%Fz_anchor ) ) THEN
       CALL C_F_POINTER( OtherStateData%C_obj%Fz_anchor, dbl_arr, (/OtherStateData%C_obj%Fz_anchor_Len/) )
       DO i = 1, OtherStateData%C_obj%Fz_anchor_Len
          OtherStateData%Fz_anchor(i) = dbl_arr(i)
       END DO
    ENDIF
 END SUBROUTINE MAP_C2F_CopyOtherState

 SUBROUTINE MAP_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MAP_otherstatetype), INTENT(INOUT) :: SrcOtherStateData
   TYPE(MAP_otherstatetype), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ASSOCIATED(SrcOtherStateData%H)) THEN
   i1_l = LBOUND(SrcOtherStateData%H,1)
   i1_u = UBOUND(SrcOtherStateData%H,1)
   IF (.NOT. ASSOCIATED(DstOtherStateData%H)) THEN 
      ALLOCATE(DstOtherStateData%H(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MAP_CopyOtherState: Error allocating DstOtherStateData%H.'
         RETURN
      END IF
   END IF
   DstOtherStateData%H = SrcOtherStateData%H
ENDIF
IF (ASSOCIATED(SrcOtherStateData%V)) THEN
   i1_l = LBOUND(SrcOtherStateData%V,1)
   i1_u = UBOUND(SrcOtherStateData%V,1)
   IF (.NOT. ASSOCIATED(DstOtherStateData%V)) THEN 
      ALLOCATE(DstOtherStateData%V(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MAP_CopyOtherState: Error allocating DstOtherStateData%V.'
         RETURN
      END IF
   END IF
   DstOtherStateData%V = SrcOtherStateData%V
ENDIF
IF (ASSOCIATED(SrcOtherStateData%Ha)) THEN
   i1_l = LBOUND(SrcOtherStateData%Ha,1)
   i1_u = UBOUND(SrcOtherStateData%Ha,1)
   IF (.NOT. ASSOCIATED(DstOtherStateData%Ha)) THEN 
      ALLOCATE(DstOtherStateData%Ha(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MAP_CopyOtherState: Error allocating DstOtherStateData%Ha.'
         RETURN
      END IF
   END IF
   DstOtherStateData%Ha = SrcOtherStateData%Ha
ENDIF
IF (ASSOCIATED(SrcOtherStateData%Va)) THEN
   i1_l = LBOUND(SrcOtherStateData%Va,1)
   i1_u = UBOUND(SrcOtherStateData%Va,1)
   IF (.NOT. ASSOCIATED(DstOtherStateData%Va)) THEN 
      ALLOCATE(DstOtherStateData%Va(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MAP_CopyOtherState: Error allocating DstOtherStateData%Va.'
         RETURN
      END IF
   END IF
   DstOtherStateData%Va = SrcOtherStateData%Va
ENDIF
IF (ASSOCIATED(SrcOtherStateData%x)) THEN
   i1_l = LBOUND(SrcOtherStateData%x,1)
   i1_u = UBOUND(SrcOtherStateData%x,1)
   IF (.NOT. ASSOCIATED(DstOtherStateData%x)) THEN 
      ALLOCATE(DstOtherStateData%x(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MAP_CopyOtherState: Error allocating DstOtherStateData%x.'
         RETURN
      END IF
   END IF
   DstOtherStateData%x = SrcOtherStateData%x
ENDIF
IF (ASSOCIATED(SrcOtherStateData%y)) THEN
   i1_l = LBOUND(SrcOtherStateData%y,1)
   i1_u = UBOUND(SrcOtherStateData%y,1)
   IF (.NOT. ASSOCIATED(DstOtherStateData%y)) THEN 
      ALLOCATE(DstOtherStateData%y(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MAP_CopyOtherState: Error allocating DstOtherStateData%y.'
         RETURN
      END IF
   END IF
   DstOtherStateData%y = SrcOtherStateData%y
ENDIF
IF (ASSOCIATED(SrcOtherStateData%z)) THEN
   i1_l = LBOUND(SrcOtherStateData%z,1)
   i1_u = UBOUND(SrcOtherStateData%z,1)
   IF (.NOT. ASSOCIATED(DstOtherStateData%z)) THEN 
      ALLOCATE(DstOtherStateData%z(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MAP_CopyOtherState: Error allocating DstOtherStateData%z.'
         RETURN
      END IF
   END IF
   DstOtherStateData%z = SrcOtherStateData%z
ENDIF
IF (ASSOCIATED(SrcOtherStateData%xa)) THEN
   i1_l = LBOUND(SrcOtherStateData%xa,1)
   i1_u = UBOUND(SrcOtherStateData%xa,1)
   IF (.NOT. ASSOCIATED(DstOtherStateData%xa)) THEN 
      ALLOCATE(DstOtherStateData%xa(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MAP_CopyOtherState: Error allocating DstOtherStateData%xa.'
         RETURN
      END IF
   END IF
   DstOtherStateData%xa = SrcOtherStateData%xa
ENDIF
IF (ASSOCIATED(SrcOtherStateData%ya)) THEN
   i1_l = LBOUND(SrcOtherStateData%ya,1)
   i1_u = UBOUND(SrcOtherStateData%ya,1)
   IF (.NOT. ASSOCIATED(DstOtherStateData%ya)) THEN 
      ALLOCATE(DstOtherStateData%ya(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MAP_CopyOtherState: Error allocating DstOtherStateData%ya.'
         RETURN
      END IF
   END IF
   DstOtherStateData%ya = SrcOtherStateData%ya
ENDIF
IF (ASSOCIATED(SrcOtherStateData%za)) THEN
   i1_l = LBOUND(SrcOtherStateData%za,1)
   i1_u = UBOUND(SrcOtherStateData%za,1)
   IF (.NOT. ASSOCIATED(DstOtherStateData%za)) THEN 
      ALLOCATE(DstOtherStateData%za(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MAP_CopyOtherState: Error allocating DstOtherStateData%za.'
         RETURN
      END IF
   END IF
   DstOtherStateData%za = SrcOtherStateData%za
ENDIF
IF (ASSOCIATED(SrcOtherStateData%Fx_connect)) THEN
   i1_l = LBOUND(SrcOtherStateData%Fx_connect,1)
   i1_u = UBOUND(SrcOtherStateData%Fx_connect,1)
   IF (.NOT. ASSOCIATED(DstOtherStateData%Fx_connect)) THEN 
      ALLOCATE(DstOtherStateData%Fx_connect(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MAP_CopyOtherState: Error allocating DstOtherStateData%Fx_connect.'
         RETURN
      END IF
   END IF
   DstOtherStateData%Fx_connect = SrcOtherStateData%Fx_connect
ENDIF
IF (ASSOCIATED(SrcOtherStateData%Fy_connect)) THEN
   i1_l = LBOUND(SrcOtherStateData%Fy_connect,1)
   i1_u = UBOUND(SrcOtherStateData%Fy_connect,1)
   IF (.NOT. ASSOCIATED(DstOtherStateData%Fy_connect)) THEN 
      ALLOCATE(DstOtherStateData%Fy_connect(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MAP_CopyOtherState: Error allocating DstOtherStateData%Fy_connect.'
         RETURN
      END IF
   END IF
   DstOtherStateData%Fy_connect = SrcOtherStateData%Fy_connect
ENDIF
IF (ASSOCIATED(SrcOtherStateData%Fz_connect)) THEN
   i1_l = LBOUND(SrcOtherStateData%Fz_connect,1)
   i1_u = UBOUND(SrcOtherStateData%Fz_connect,1)
   IF (.NOT. ASSOCIATED(DstOtherStateData%Fz_connect)) THEN 
      ALLOCATE(DstOtherStateData%Fz_connect(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MAP_CopyOtherState: Error allocating DstOtherStateData%Fz_connect.'
         RETURN
      END IF
   END IF
   DstOtherStateData%Fz_connect = SrcOtherStateData%Fz_connect
ENDIF
IF (ASSOCIATED(SrcOtherStateData%Fx_anchor)) THEN
   i1_l = LBOUND(SrcOtherStateData%Fx_anchor,1)
   i1_u = UBOUND(SrcOtherStateData%Fx_anchor,1)
   IF (.NOT. ASSOCIATED(DstOtherStateData%Fx_anchor)) THEN 
      ALLOCATE(DstOtherStateData%Fx_anchor(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MAP_CopyOtherState: Error allocating DstOtherStateData%Fx_anchor.'
         RETURN
      END IF
   END IF
   DstOtherStateData%Fx_anchor = SrcOtherStateData%Fx_anchor
ENDIF
IF (ASSOCIATED(SrcOtherStateData%Fy_anchor)) THEN
   i1_l = LBOUND(SrcOtherStateData%Fy_anchor,1)
   i1_u = UBOUND(SrcOtherStateData%Fy_anchor,1)
   IF (.NOT. ASSOCIATED(DstOtherStateData%Fy_anchor)) THEN 
      ALLOCATE(DstOtherStateData%Fy_anchor(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MAP_CopyOtherState: Error allocating DstOtherStateData%Fy_anchor.'
         RETURN
      END IF
   END IF
   DstOtherStateData%Fy_anchor = SrcOtherStateData%Fy_anchor
ENDIF
IF (ASSOCIATED(SrcOtherStateData%Fz_anchor)) THEN
   i1_l = LBOUND(SrcOtherStateData%Fz_anchor,1)
   i1_u = UBOUND(SrcOtherStateData%Fz_anchor,1)
   IF (.NOT. ASSOCIATED(DstOtherStateData%Fz_anchor)) THEN 
      ALLOCATE(DstOtherStateData%Fz_anchor(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MAP_CopyOtherState: Error allocating DstOtherStateData%Fz_anchor.'
         RETURN
      END IF
   END IF
   DstOtherStateData%Fz_anchor = SrcOtherStateData%Fz_anchor
ENDIF
 END SUBROUTINE MAP_CopyOtherState

 SUBROUTINE MAP_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(MAP_otherstatetype), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE MAP_DestroyOtherState

 SUBROUTINE MAP_PackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MAP_otherstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz    = Db_BufSz    + SIZE( InData%H )  ! H 
  Db_BufSz    = Db_BufSz    + SIZE( InData%V )  ! V 
  Db_BufSz    = Db_BufSz    + SIZE( InData%Ha )  ! Ha 
  Db_BufSz    = Db_BufSz    + SIZE( InData%Va )  ! Va 
  Db_BufSz    = Db_BufSz    + SIZE( InData%x )  ! x 
  Db_BufSz    = Db_BufSz    + SIZE( InData%y )  ! y 
  Db_BufSz    = Db_BufSz    + SIZE( InData%z )  ! z 
  Db_BufSz    = Db_BufSz    + SIZE( InData%xa )  ! xa 
  Db_BufSz    = Db_BufSz    + SIZE( InData%ya )  ! ya 
  Db_BufSz    = Db_BufSz    + SIZE( InData%za )  ! za 
  Db_BufSz    = Db_BufSz    + SIZE( InData%Fx_connect )  ! Fx_connect 
  Db_BufSz    = Db_BufSz    + SIZE( InData%Fy_connect )  ! Fy_connect 
  Db_BufSz    = Db_BufSz    + SIZE( InData%Fz_connect )  ! Fz_connect 
  Db_BufSz    = Db_BufSz    + SIZE( InData%Fx_anchor )  ! Fx_anchor 
  Db_BufSz    = Db_BufSz    + SIZE( InData%Fy_anchor )  ! Fy_anchor 
  Db_BufSz    = Db_BufSz    + SIZE( InData%Fz_anchor )  ! Fz_anchor 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ASSOCIATED(InData%H) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%H))-1 ) =  PACK(InData%H ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%H)
  ENDIF
  IF ( ASSOCIATED(InData%V) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%V))-1 ) =  PACK(InData%V ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%V)
  ENDIF
  IF ( ASSOCIATED(InData%Ha) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%Ha))-1 ) =  PACK(InData%Ha ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%Ha)
  ENDIF
  IF ( ASSOCIATED(InData%Va) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%Va))-1 ) =  PACK(InData%Va ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%Va)
  ENDIF
  IF ( ASSOCIATED(InData%x) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%x))-1 ) =  PACK(InData%x ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%x)
  ENDIF
  IF ( ASSOCIATED(InData%y) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%y))-1 ) =  PACK(InData%y ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%y)
  ENDIF
  IF ( ASSOCIATED(InData%z) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%z))-1 ) =  PACK(InData%z ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%z)
  ENDIF
  IF ( ASSOCIATED(InData%xa) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%xa))-1 ) =  PACK(InData%xa ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%xa)
  ENDIF
  IF ( ASSOCIATED(InData%ya) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%ya))-1 ) =  PACK(InData%ya ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%ya)
  ENDIF
  IF ( ASSOCIATED(InData%za) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%za))-1 ) =  PACK(InData%za ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%za)
  ENDIF
  IF ( ASSOCIATED(InData%Fx_connect) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%Fx_connect))-1 ) =  PACK(InData%Fx_connect ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%Fx_connect)
  ENDIF
  IF ( ASSOCIATED(InData%Fy_connect) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%Fy_connect))-1 ) =  PACK(InData%Fy_connect ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%Fy_connect)
  ENDIF
  IF ( ASSOCIATED(InData%Fz_connect) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%Fz_connect))-1 ) =  PACK(InData%Fz_connect ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%Fz_connect)
  ENDIF
  IF ( ASSOCIATED(InData%Fx_anchor) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%Fx_anchor))-1 ) =  PACK(InData%Fx_anchor ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%Fx_anchor)
  ENDIF
  IF ( ASSOCIATED(InData%Fy_anchor) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%Fy_anchor))-1 ) =  PACK(InData%Fy_anchor ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%Fy_anchor)
  ENDIF
  IF ( ASSOCIATED(InData%Fz_anchor) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%Fz_anchor))-1 ) =  PACK(InData%Fz_anchor ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%Fz_anchor)
  ENDIF
 END SUBROUTINE MAP_PackOtherState

 SUBROUTINE MAP_UnPackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MAP_otherstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ASSOCIATED(OutData%H) ) THEN
  ALLOCATE(mask1(SIZE(OutData%H,1))); mask1 = .TRUE.
    OutData%H = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%H))-1 ),mask1,OutData%H)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%H)
  ENDIF
  IF ( ASSOCIATED(OutData%V) ) THEN
  ALLOCATE(mask1(SIZE(OutData%V,1))); mask1 = .TRUE.
    OutData%V = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%V))-1 ),mask1,OutData%V)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%V)
  ENDIF
  IF ( ASSOCIATED(OutData%Ha) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Ha,1))); mask1 = .TRUE.
    OutData%Ha = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%Ha))-1 ),mask1,OutData%Ha)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%Ha)
  ENDIF
  IF ( ASSOCIATED(OutData%Va) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Va,1))); mask1 = .TRUE.
    OutData%Va = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%Va))-1 ),mask1,OutData%Va)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%Va)
  ENDIF
  IF ( ASSOCIATED(OutData%x) ) THEN
  ALLOCATE(mask1(SIZE(OutData%x,1))); mask1 = .TRUE.
    OutData%x = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%x))-1 ),mask1,OutData%x)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%x)
  ENDIF
  IF ( ASSOCIATED(OutData%y) ) THEN
  ALLOCATE(mask1(SIZE(OutData%y,1))); mask1 = .TRUE.
    OutData%y = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%y))-1 ),mask1,OutData%y)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%y)
  ENDIF
  IF ( ASSOCIATED(OutData%z) ) THEN
  ALLOCATE(mask1(SIZE(OutData%z,1))); mask1 = .TRUE.
    OutData%z = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%z))-1 ),mask1,OutData%z)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%z)
  ENDIF
  IF ( ASSOCIATED(OutData%xa) ) THEN
  ALLOCATE(mask1(SIZE(OutData%xa,1))); mask1 = .TRUE.
    OutData%xa = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%xa))-1 ),mask1,OutData%xa)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%xa)
  ENDIF
  IF ( ASSOCIATED(OutData%ya) ) THEN
  ALLOCATE(mask1(SIZE(OutData%ya,1))); mask1 = .TRUE.
    OutData%ya = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%ya))-1 ),mask1,OutData%ya)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%ya)
  ENDIF
  IF ( ASSOCIATED(OutData%za) ) THEN
  ALLOCATE(mask1(SIZE(OutData%za,1))); mask1 = .TRUE.
    OutData%za = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%za))-1 ),mask1,OutData%za)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%za)
  ENDIF
  IF ( ASSOCIATED(OutData%Fx_connect) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Fx_connect,1))); mask1 = .TRUE.
    OutData%Fx_connect = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%Fx_connect))-1 ),mask1,OutData%Fx_connect)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%Fx_connect)
  ENDIF
  IF ( ASSOCIATED(OutData%Fy_connect) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Fy_connect,1))); mask1 = .TRUE.
    OutData%Fy_connect = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%Fy_connect))-1 ),mask1,OutData%Fy_connect)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%Fy_connect)
  ENDIF
  IF ( ASSOCIATED(OutData%Fz_connect) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Fz_connect,1))); mask1 = .TRUE.
    OutData%Fz_connect = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%Fz_connect))-1 ),mask1,OutData%Fz_connect)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%Fz_connect)
  ENDIF
  IF ( ASSOCIATED(OutData%Fx_anchor) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Fx_anchor,1))); mask1 = .TRUE.
    OutData%Fx_anchor = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%Fx_anchor))-1 ),mask1,OutData%Fx_anchor)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%Fx_anchor)
  ENDIF
  IF ( ASSOCIATED(OutData%Fy_anchor) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Fy_anchor,1))); mask1 = .TRUE.
    OutData%Fy_anchor = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%Fy_anchor))-1 ),mask1,OutData%Fy_anchor)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%Fy_anchor)
  ENDIF
  IF ( ASSOCIATED(OutData%Fz_anchor) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Fz_anchor,1))); mask1 = .TRUE.
    OutData%Fz_anchor = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%Fz_anchor))-1 ),mask1,OutData%Fz_anchor)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%Fz_anchor)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MAP_UnPackOtherState

  SUBROUTINE MAP_F2C_CopyConstrState( ConstrStateData, ErrStat, ErrMsg )
    TYPE(MAP_constraintstatetype), INTENT(INOUT) :: ConstrStateData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local 
    INTEGER(IntKi)                   :: i,i1,i2,i3,i4,i5,j,k
    REAL(KIND=C_DOUBLE) ,ALLOCATABLE :: c_dbl_value(:)
    REAL(KIND=C_DOUBLE) ,POINTER     :: dbl_arr(:)
    REAL(KIND=C_FLOAT)  ,ALLOCATABLE :: c_float_value(:)
    REAL(KIND=C_FLOAT)  ,POINTER     :: float_arr(:)
    INTEGER(KIND=C_INT) ,ALLOCATABLE :: c_int_value(:)
    INTEGER(KIND=C_INT) ,POINTER     :: int_arr(:)
    LOGICAL(KIND=C_BOOL),ALLOCATABLE :: c_bool_value(:)
    LOGICAL(KIND=C_BOOL),POINTER     :: bool_arr(:)
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""

    ! -- H ConstrState Data fields
    IF ( ASSOCIATED( ConstrStateData%H ) ) THEN
       ALLOCATE( c_dbl_value(ConstrStateData%C_obj%H_Len) )
       DO i = 1 , ConstrStateData%C_obj%H_Len
          c_dbl_value(i) = ConstrStateData%H(i)
       END DO
       CALL MAP_F2C_ConstrState_H( ConstrStateData%C_obj, c_dbl_value, ConstrStateData%C_obj%H_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- V ConstrState Data fields
    IF ( ASSOCIATED( ConstrStateData%V ) ) THEN
       ALLOCATE( c_dbl_value(ConstrStateData%C_obj%V_Len) )
       DO i = 1 , ConstrStateData%C_obj%V_Len
          c_dbl_value(i) = ConstrStateData%V(i)
       END DO
       CALL MAP_F2C_ConstrState_V( ConstrStateData%C_obj, c_dbl_value, ConstrStateData%C_obj%V_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- x ConstrState Data fields
    IF ( ASSOCIATED( ConstrStateData%x ) ) THEN
       ALLOCATE( c_dbl_value(ConstrStateData%C_obj%x_Len) )
       DO i = 1 , ConstrStateData%C_obj%x_Len
          c_dbl_value(i) = ConstrStateData%x(i)
       END DO
       CALL MAP_F2C_ConstrState_x( ConstrStateData%C_obj, c_dbl_value, ConstrStateData%C_obj%x_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- y ConstrState Data fields
    IF ( ASSOCIATED( ConstrStateData%y ) ) THEN
       ALLOCATE( c_dbl_value(ConstrStateData%C_obj%y_Len) )
       DO i = 1 , ConstrStateData%C_obj%y_Len
          c_dbl_value(i) = ConstrStateData%y(i)
       END DO
       CALL MAP_F2C_ConstrState_y( ConstrStateData%C_obj, c_dbl_value, ConstrStateData%C_obj%y_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- z ConstrState Data fields
    IF ( ASSOCIATED( ConstrStateData%z ) ) THEN
       ALLOCATE( c_dbl_value(ConstrStateData%C_obj%z_Len) )
       DO i = 1 , ConstrStateData%C_obj%z_Len
          c_dbl_value(i) = ConstrStateData%z(i)
       END DO
       CALL MAP_F2C_ConstrState_z( ConstrStateData%C_obj, c_dbl_value, ConstrStateData%C_obj%z_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF
 END SUBROUTINE MAP_F2C_CopyConstrState

  SUBROUTINE MAP_C2F_CopyConstrState( ConstrStateData, ErrStat, ErrMsg )
    TYPE(MAP_constraintstatetype), INTENT(INOUT) :: ConstrStateData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local 
    INTEGER(IntKi)                   :: i,i1,i2,i3,i4,i5,j,k
    REAL(KIND=C_DOUBLE) ,ALLOCATABLE :: c_dbl_value(:)
    REAL(KIND=C_DOUBLE) ,POINTER     :: dbl_arr(:)
    REAL(KIND=C_FLOAT)  ,ALLOCATABLE :: c_float_value(:)
    REAL(KIND=C_FLOAT)  ,POINTER     :: float_arr(:)
    INTEGER(KIND=C_INT) ,ALLOCATABLE :: c_int_value(:)
    INTEGER(KIND=C_INT) ,POINTER     :: int_arr(:)
    LOGICAL(KIND=C_BOOL),ALLOCATABLE :: c_bool_value(:)
    LOGICAL(KIND=C_BOOL),POINTER     :: bool_arr(:)
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""

    ! -- H ConstrState Data fields
    IF ( ASSOCIATED( ConstrStateData%H ) ) THEN
       CALL C_F_POINTER( ConstrStateData%C_obj%H, dbl_arr, (/ConstrStateData%C_obj%H_Len/) )
       DO i = 1, ConstrStateData%C_obj%H_Len
          ConstrStateData%H(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- V ConstrState Data fields
    IF ( ASSOCIATED( ConstrStateData%V ) ) THEN
       CALL C_F_POINTER( ConstrStateData%C_obj%V, dbl_arr, (/ConstrStateData%C_obj%V_Len/) )
       DO i = 1, ConstrStateData%C_obj%V_Len
          ConstrStateData%V(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- x ConstrState Data fields
    IF ( ASSOCIATED( ConstrStateData%x ) ) THEN
       CALL C_F_POINTER( ConstrStateData%C_obj%x, dbl_arr, (/ConstrStateData%C_obj%x_Len/) )
       DO i = 1, ConstrStateData%C_obj%x_Len
          ConstrStateData%x(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- y ConstrState Data fields
    IF ( ASSOCIATED( ConstrStateData%y ) ) THEN
       CALL C_F_POINTER( ConstrStateData%C_obj%y, dbl_arr, (/ConstrStateData%C_obj%y_Len/) )
       DO i = 1, ConstrStateData%C_obj%y_Len
          ConstrStateData%y(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- z ConstrState Data fields
    IF ( ASSOCIATED( ConstrStateData%z ) ) THEN
       CALL C_F_POINTER( ConstrStateData%C_obj%z, dbl_arr, (/ConstrStateData%C_obj%z_Len/) )
       DO i = 1, ConstrStateData%C_obj%z_Len
          ConstrStateData%z(i) = dbl_arr(i)
       END DO
    ENDIF
 END SUBROUTINE MAP_C2F_CopyConstrState

 SUBROUTINE MAP_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MAP_constraintstatetype), INTENT(INOUT) :: SrcConstrStateData
   TYPE(MAP_constraintstatetype), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ASSOCIATED(SrcConstrStateData%H)) THEN
   i1_l = LBOUND(SrcConstrStateData%H,1)
   i1_u = UBOUND(SrcConstrStateData%H,1)
   IF (.NOT. ASSOCIATED(DstConstrStateData%H)) THEN 
      ALLOCATE(DstConstrStateData%H(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MAP_CopyConstrState: Error allocating DstConstrStateData%H.'
         RETURN
      END IF
   END IF
   DstConstrStateData%H = SrcConstrStateData%H
ENDIF
IF (ASSOCIATED(SrcConstrStateData%V)) THEN
   i1_l = LBOUND(SrcConstrStateData%V,1)
   i1_u = UBOUND(SrcConstrStateData%V,1)
   IF (.NOT. ASSOCIATED(DstConstrStateData%V)) THEN 
      ALLOCATE(DstConstrStateData%V(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MAP_CopyConstrState: Error allocating DstConstrStateData%V.'
         RETURN
      END IF
   END IF
   DstConstrStateData%V = SrcConstrStateData%V
ENDIF
IF (ASSOCIATED(SrcConstrStateData%x)) THEN
   i1_l = LBOUND(SrcConstrStateData%x,1)
   i1_u = UBOUND(SrcConstrStateData%x,1)
   IF (.NOT. ASSOCIATED(DstConstrStateData%x)) THEN 
      ALLOCATE(DstConstrStateData%x(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MAP_CopyConstrState: Error allocating DstConstrStateData%x.'
         RETURN
      END IF
   END IF
   DstConstrStateData%x = SrcConstrStateData%x
ENDIF
IF (ASSOCIATED(SrcConstrStateData%y)) THEN
   i1_l = LBOUND(SrcConstrStateData%y,1)
   i1_u = UBOUND(SrcConstrStateData%y,1)
   IF (.NOT. ASSOCIATED(DstConstrStateData%y)) THEN 
      ALLOCATE(DstConstrStateData%y(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MAP_CopyConstrState: Error allocating DstConstrStateData%y.'
         RETURN
      END IF
   END IF
   DstConstrStateData%y = SrcConstrStateData%y
ENDIF
IF (ASSOCIATED(SrcConstrStateData%z)) THEN
   i1_l = LBOUND(SrcConstrStateData%z,1)
   i1_u = UBOUND(SrcConstrStateData%z,1)
   IF (.NOT. ASSOCIATED(DstConstrStateData%z)) THEN 
      ALLOCATE(DstConstrStateData%z(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MAP_CopyConstrState: Error allocating DstConstrStateData%z.'
         RETURN
      END IF
   END IF
   DstConstrStateData%z = SrcConstrStateData%z
ENDIF
 END SUBROUTINE MAP_CopyConstrState

 SUBROUTINE MAP_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(MAP_constraintstatetype), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE MAP_DestroyConstrState

 SUBROUTINE MAP_PackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MAP_constraintstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz    = Db_BufSz    + SIZE( InData%H )  ! H 
  Db_BufSz    = Db_BufSz    + SIZE( InData%V )  ! V 
  Db_BufSz    = Db_BufSz    + SIZE( InData%x )  ! x 
  Db_BufSz    = Db_BufSz    + SIZE( InData%y )  ! y 
  Db_BufSz    = Db_BufSz    + SIZE( InData%z )  ! z 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ASSOCIATED(InData%H) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%H))-1 ) =  PACK(InData%H ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%H)
  ENDIF
  IF ( ASSOCIATED(InData%V) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%V))-1 ) =  PACK(InData%V ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%V)
  ENDIF
  IF ( ASSOCIATED(InData%x) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%x))-1 ) =  PACK(InData%x ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%x)
  ENDIF
  IF ( ASSOCIATED(InData%y) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%y))-1 ) =  PACK(InData%y ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%y)
  ENDIF
  IF ( ASSOCIATED(InData%z) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%z))-1 ) =  PACK(InData%z ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%z)
  ENDIF
 END SUBROUTINE MAP_PackConstrState

 SUBROUTINE MAP_UnPackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MAP_constraintstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ASSOCIATED(OutData%H) ) THEN
  ALLOCATE(mask1(SIZE(OutData%H,1))); mask1 = .TRUE.
    OutData%H = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%H))-1 ),mask1,OutData%H)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%H)
  ENDIF
  IF ( ASSOCIATED(OutData%V) ) THEN
  ALLOCATE(mask1(SIZE(OutData%V,1))); mask1 = .TRUE.
    OutData%V = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%V))-1 ),mask1,OutData%V)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%V)
  ENDIF
  IF ( ASSOCIATED(OutData%x) ) THEN
  ALLOCATE(mask1(SIZE(OutData%x,1))); mask1 = .TRUE.
    OutData%x = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%x))-1 ),mask1,OutData%x)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%x)
  ENDIF
  IF ( ASSOCIATED(OutData%y) ) THEN
  ALLOCATE(mask1(SIZE(OutData%y,1))); mask1 = .TRUE.
    OutData%y = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%y))-1 ),mask1,OutData%y)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%y)
  ENDIF
  IF ( ASSOCIATED(OutData%z) ) THEN
  ALLOCATE(mask1(SIZE(OutData%z,1))); mask1 = .TRUE.
    OutData%z = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%z))-1 ),mask1,OutData%z)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%z)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MAP_UnPackConstrState

  SUBROUTINE MAP_F2C_CopyParam( ParamData, ErrStat, ErrMsg )
    TYPE(MAP_parametertype), INTENT(INOUT) :: ParamData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local 
    INTEGER(IntKi)                   :: i,i1,i2,i3,i4,i5,j,k
    REAL(KIND=C_DOUBLE) ,ALLOCATABLE :: c_dbl_value(:)
    REAL(KIND=C_DOUBLE) ,POINTER     :: dbl_arr(:)
    REAL(KIND=C_FLOAT)  ,ALLOCATABLE :: c_float_value(:)
    REAL(KIND=C_FLOAT)  ,POINTER     :: float_arr(:)
    INTEGER(KIND=C_INT) ,ALLOCATABLE :: c_int_value(:)
    INTEGER(KIND=C_INT) ,POINTER     :: int_arr(:)
    LOGICAL(KIND=C_BOOL),ALLOCATABLE :: c_bool_value(:)
    LOGICAL(KIND=C_BOOL),POINTER     :: bool_arr(:)
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""
    ParamData%C_obj%g = ParamData%g
    ParamData%C_obj%depth = ParamData%depth
    ParamData%C_obj%rhoSea = ParamData%rhoSea
 END SUBROUTINE MAP_F2C_CopyParam

  SUBROUTINE MAP_C2F_CopyParam( ParamData, ErrStat, ErrMsg )
    TYPE(MAP_parametertype), INTENT(INOUT) :: ParamData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local 
    INTEGER(IntKi)                   :: i,i1,i2,i3,i4,i5,j,k
    REAL(KIND=C_DOUBLE) ,ALLOCATABLE :: c_dbl_value(:)
    REAL(KIND=C_DOUBLE) ,POINTER     :: dbl_arr(:)
    REAL(KIND=C_FLOAT)  ,ALLOCATABLE :: c_float_value(:)
    REAL(KIND=C_FLOAT)  ,POINTER     :: float_arr(:)
    INTEGER(KIND=C_INT) ,ALLOCATABLE :: c_int_value(:)
    INTEGER(KIND=C_INT) ,POINTER     :: int_arr(:)
    LOGICAL(KIND=C_BOOL),ALLOCATABLE :: c_bool_value(:)
    LOGICAL(KIND=C_BOOL),POINTER     :: bool_arr(:)
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""
    ParamData%g = ParamData%C_obj%g
    ParamData%depth = ParamData%C_obj%depth
    ParamData%rhoSea = ParamData%C_obj%rhoSea
 END SUBROUTINE MAP_C2F_CopyParam

 SUBROUTINE MAP_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MAP_parametertype), INTENT(INOUT) :: SrcParamData
   TYPE(MAP_parametertype), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstParamData%g = SrcParamData%g
   DstParamData%depth = SrcParamData%depth
   DstParamData%rhoSea = SrcParamData%rhoSea
 END SUBROUTINE MAP_CopyParam

 SUBROUTINE MAP_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(MAP_parametertype), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE MAP_DestroyParam

 SUBROUTINE MAP_PackParam( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MAP_parametertype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz   = Db_BufSz   + 1  ! g
  Db_BufSz   = Db_BufSz   + 1  ! depth
  Db_BufSz   = Db_BufSz   + 1  ! rhoSea
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%g )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%depth )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%rhoSea )
  Db_Xferred   = Db_Xferred   + 1
 END SUBROUTINE MAP_PackParam

 SUBROUTINE MAP_UnPackParam( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MAP_parametertype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%g = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%depth = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%rhoSea = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MAP_UnPackParam

  SUBROUTINE MAP_F2C_CopyInput( InputData, ErrStat, ErrMsg )
    TYPE(MAP_inputtype), INTENT(INOUT) :: InputData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local 
    INTEGER(IntKi)                   :: i,i1,i2,i3,i4,i5,j,k
    REAL(KIND=C_DOUBLE) ,ALLOCATABLE :: c_dbl_value(:)
    REAL(KIND=C_DOUBLE) ,POINTER     :: dbl_arr(:)
    REAL(KIND=C_FLOAT)  ,ALLOCATABLE :: c_float_value(:)
    REAL(KIND=C_FLOAT)  ,POINTER     :: float_arr(:)
    INTEGER(KIND=C_INT) ,ALLOCATABLE :: c_int_value(:)
    INTEGER(KIND=C_INT) ,POINTER     :: int_arr(:)
    LOGICAL(KIND=C_BOOL),ALLOCATABLE :: c_bool_value(:)
    LOGICAL(KIND=C_BOOL),POINTER     :: bool_arr(:)
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""

    ! -- x Input Data fields
    IF ( ASSOCIATED( InputData%x ) ) THEN
       ALLOCATE( c_dbl_value(InputData%C_obj%x_Len) )
       DO i = 1 , InputData%C_obj%x_Len
          c_dbl_value(i) = InputData%x(i)
       END DO
       CALL MAP_F2C_Input_x( InputData%C_obj, c_dbl_value, InputData%C_obj%x_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- y Input Data fields
    IF ( ASSOCIATED( InputData%y ) ) THEN
       ALLOCATE( c_dbl_value(InputData%C_obj%y_Len) )
       DO i = 1 , InputData%C_obj%y_Len
          c_dbl_value(i) = InputData%y(i)
       END DO
       CALL MAP_F2C_Input_y( InputData%C_obj, c_dbl_value, InputData%C_obj%y_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- z Input Data fields
    IF ( ASSOCIATED( InputData%z ) ) THEN
       ALLOCATE( c_dbl_value(InputData%C_obj%z_Len) )
       DO i = 1 , InputData%C_obj%z_Len
          c_dbl_value(i) = InputData%z(i)
       END DO
       CALL MAP_F2C_Input_z( InputData%C_obj, c_dbl_value, InputData%C_obj%z_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF
 END SUBROUTINE MAP_F2C_CopyInput

  SUBROUTINE MAP_C2F_CopyInput( InputData, ErrStat, ErrMsg )
    TYPE(MAP_inputtype), INTENT(INOUT) :: InputData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local 
    INTEGER(IntKi)                   :: i,i1,i2,i3,i4,i5,j,k
    REAL(KIND=C_DOUBLE) ,ALLOCATABLE :: c_dbl_value(:)
    REAL(KIND=C_DOUBLE) ,POINTER     :: dbl_arr(:)
    REAL(KIND=C_FLOAT)  ,ALLOCATABLE :: c_float_value(:)
    REAL(KIND=C_FLOAT)  ,POINTER     :: float_arr(:)
    INTEGER(KIND=C_INT) ,ALLOCATABLE :: c_int_value(:)
    INTEGER(KIND=C_INT) ,POINTER     :: int_arr(:)
    LOGICAL(KIND=C_BOOL),ALLOCATABLE :: c_bool_value(:)
    LOGICAL(KIND=C_BOOL),POINTER     :: bool_arr(:)
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""

    ! -- x Input Data fields
    IF ( ASSOCIATED( InputData%x ) ) THEN
       CALL C_F_POINTER( InputData%C_obj%x, dbl_arr, (/InputData%C_obj%x_Len/) )
       DO i = 1, InputData%C_obj%x_Len
          InputData%x(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- y Input Data fields
    IF ( ASSOCIATED( InputData%y ) ) THEN
       CALL C_F_POINTER( InputData%C_obj%y, dbl_arr, (/InputData%C_obj%y_Len/) )
       DO i = 1, InputData%C_obj%y_Len
          InputData%y(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- z Input Data fields
    IF ( ASSOCIATED( InputData%z ) ) THEN
       CALL C_F_POINTER( InputData%C_obj%z, dbl_arr, (/InputData%C_obj%z_Len/) )
       DO i = 1, InputData%C_obj%z_Len
          InputData%z(i) = dbl_arr(i)
       END DO
    ENDIF
 END SUBROUTINE MAP_C2F_CopyInput

 SUBROUTINE MAP_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MAP_inputtype), INTENT(INOUT) :: SrcInputData
   TYPE(MAP_inputtype), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ASSOCIATED(SrcInputData%x)) THEN
   i1_l = LBOUND(SrcInputData%x,1)
   i1_u = UBOUND(SrcInputData%x,1)
   IF (.NOT. ASSOCIATED(DstInputData%x)) THEN 
      ALLOCATE(DstInputData%x(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MAP_CopyInput: Error allocating DstInputData%x.'
         RETURN
      END IF
   END IF
   DstInputData%x = SrcInputData%x
ENDIF
IF (ASSOCIATED(SrcInputData%y)) THEN
   i1_l = LBOUND(SrcInputData%y,1)
   i1_u = UBOUND(SrcInputData%y,1)
   IF (.NOT. ASSOCIATED(DstInputData%y)) THEN 
      ALLOCATE(DstInputData%y(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MAP_CopyInput: Error allocating DstInputData%y.'
         RETURN
      END IF
   END IF
   DstInputData%y = SrcInputData%y
ENDIF
IF (ASSOCIATED(SrcInputData%z)) THEN
   i1_l = LBOUND(SrcInputData%z,1)
   i1_u = UBOUND(SrcInputData%z,1)
   IF (.NOT. ASSOCIATED(DstInputData%z)) THEN 
      ALLOCATE(DstInputData%z(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MAP_CopyInput: Error allocating DstInputData%z.'
         RETURN
      END IF
   END IF
   DstInputData%z = SrcInputData%z
ENDIF
  DstInputData%C_obj = SrcInputData%C_obj
     CALL MeshCopy( SrcInputData%PtFairDisplacement, DstInputData%PtFairDisplacement, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE MAP_CopyInput

 SUBROUTINE MAP_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(MAP_inputtype), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL MeshDestroy( InputData%PtFairDisplacement, ErrStat, ErrMsg )
 END SUBROUTINE MAP_DestroyInput

 SUBROUTINE MAP_PackInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MAP_inputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_PtFairDisplacement_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_PtFairDisplacement_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_PtFairDisplacement_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz    = Db_BufSz    + SIZE( InData%x )  ! x 
  Db_BufSz    = Db_BufSz    + SIZE( InData%y )  ! y 
  Db_BufSz    = Db_BufSz    + SIZE( InData%z )  ! z 
 ! Allocate mesh buffers, if any (we'll also get sizes from these) 
  CALL MeshPack( InData%PtFairDisplacement, Re_PtFairDisplacement_Buf, Db_PtFairDisplacement_Buf, Int_PtFairDisplacement_Buf, ErrStat, ErrMsg, .TRUE. ) ! PtFairDisplacement 
  IF(ALLOCATED(Re_PtFairDisplacement_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_PtFairDisplacement_Buf  ) ! PtFairDisplacement
  IF(ALLOCATED(Db_PtFairDisplacement_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_PtFairDisplacement_Buf  ) ! PtFairDisplacement
  IF(ALLOCATED(Int_PtFairDisplacement_Buf))Int_BufSz = Int_BufSz + SIZE( Int_PtFairDisplacement_Buf ) ! PtFairDisplacement
  IF(ALLOCATED(Re_PtFairDisplacement_Buf))  DEALLOCATE(Re_PtFairDisplacement_Buf)
  IF(ALLOCATED(Db_PtFairDisplacement_Buf))  DEALLOCATE(Db_PtFairDisplacement_Buf)
  IF(ALLOCATED(Int_PtFairDisplacement_Buf)) DEALLOCATE(Int_PtFairDisplacement_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ASSOCIATED(InData%x) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%x))-1 ) =  PACK(InData%x ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%x)
  ENDIF
  IF ( ASSOCIATED(InData%y) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%y))-1 ) =  PACK(InData%y ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%y)
  ENDIF
  IF ( ASSOCIATED(InData%z) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%z))-1 ) =  PACK(InData%z ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%z)
  ENDIF
  CALL MeshPack( InData%PtFairDisplacement, Re_PtFairDisplacement_Buf, Db_PtFairDisplacement_Buf, Int_PtFairDisplacement_Buf, ErrStat, ErrMsg, OnlySize ) ! PtFairDisplacement 
  IF(ALLOCATED(Re_PtFairDisplacement_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_PtFairDisplacement_Buf)-1 ) = Re_PtFairDisplacement_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_PtFairDisplacement_Buf)
  ENDIF
  IF(ALLOCATED(Db_PtFairDisplacement_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_PtFairDisplacement_Buf)-1 ) = Db_PtFairDisplacement_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_PtFairDisplacement_Buf)
  ENDIF
  IF(ALLOCATED(Int_PtFairDisplacement_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_PtFairDisplacement_Buf)-1 ) = Int_PtFairDisplacement_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_PtFairDisplacement_Buf)
  ENDIF
  IF( ALLOCATED(Re_PtFairDisplacement_Buf) )  DEALLOCATE(Re_PtFairDisplacement_Buf)
  IF( ALLOCATED(Db_PtFairDisplacement_Buf) )  DEALLOCATE(Db_PtFairDisplacement_Buf)
  IF( ALLOCATED(Int_PtFairDisplacement_Buf) ) DEALLOCATE(Int_PtFairDisplacement_Buf)
 END SUBROUTINE MAP_PackInput

 SUBROUTINE MAP_UnPackInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MAP_inputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_PtFairDisplacement_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_PtFairDisplacement_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_PtFairDisplacement_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ASSOCIATED(OutData%x) ) THEN
  ALLOCATE(mask1(SIZE(OutData%x,1))); mask1 = .TRUE.
    OutData%x = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%x))-1 ),mask1,OutData%x)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%x)
  ENDIF
  IF ( ASSOCIATED(OutData%y) ) THEN
  ALLOCATE(mask1(SIZE(OutData%y,1))); mask1 = .TRUE.
    OutData%y = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%y))-1 ),mask1,OutData%y)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%y)
  ENDIF
  IF ( ASSOCIATED(OutData%z) ) THEN
  ALLOCATE(mask1(SIZE(OutData%z,1))); mask1 = .TRUE.
    OutData%z = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%z))-1 ),mask1,OutData%z)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%z)
  ENDIF
 ! first call MeshPack to get correctly sized buffers for unpacking
  CALL MeshPack( OutData%PtFairDisplacement, Re_PtFairDisplacement_Buf, Db_PtFairDisplacement_Buf, Int_PtFairDisplacement_Buf, ErrStat, ErrMsg , .TRUE. ) ! PtFairDisplacement 
  IF(ALLOCATED(Re_PtFairDisplacement_Buf)) THEN
    Re_PtFairDisplacement_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_PtFairDisplacement_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_PtFairDisplacement_Buf)
  ENDIF
  IF(ALLOCATED(Db_PtFairDisplacement_Buf)) THEN
    Db_PtFairDisplacement_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_PtFairDisplacement_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_PtFairDisplacement_Buf)
  ENDIF
  IF(ALLOCATED(Int_PtFairDisplacement_Buf)) THEN
    Int_PtFairDisplacement_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_PtFairDisplacement_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_PtFairDisplacement_Buf)
  ENDIF
  CALL MeshUnPack( OutData%PtFairDisplacement, Re_PtFairDisplacement_Buf, Db_PtFairDisplacement_Buf, Int_PtFairDisplacement_Buf, ErrStat, ErrMsg ) ! PtFairDisplacement 
  IF( ALLOCATED(Re_PtFairDisplacement_Buf) )  DEALLOCATE(Re_PtFairDisplacement_Buf)
  IF( ALLOCATED(Db_PtFairDisplacement_Buf) )  DEALLOCATE(Db_PtFairDisplacement_Buf)
  IF( ALLOCATED(Int_PtFairDisplacement_Buf) ) DEALLOCATE(Int_PtFairDisplacement_Buf)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MAP_UnPackInput

  SUBROUTINE MAP_F2C_CopyOutput( OutputData, ErrStat, ErrMsg )
    TYPE(MAP_outputtype), INTENT(INOUT) :: OutputData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local 
    INTEGER(IntKi)                   :: i,i1,i2,i3,i4,i5,j,k
    REAL(KIND=C_DOUBLE) ,ALLOCATABLE :: c_dbl_value(:)
    REAL(KIND=C_DOUBLE) ,POINTER     :: dbl_arr(:)
    REAL(KIND=C_FLOAT)  ,ALLOCATABLE :: c_float_value(:)
    REAL(KIND=C_FLOAT)  ,POINTER     :: float_arr(:)
    INTEGER(KIND=C_INT) ,ALLOCATABLE :: c_int_value(:)
    INTEGER(KIND=C_INT) ,POINTER     :: int_arr(:)
    LOGICAL(KIND=C_BOOL),ALLOCATABLE :: c_bool_value(:)
    LOGICAL(KIND=C_BOOL),POINTER     :: bool_arr(:)
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""

    ! -- Fx Output Data fields
    IF ( ASSOCIATED( OutputData%Fx ) ) THEN
       ALLOCATE( c_dbl_value(OutputData%C_obj%Fx_Len) )
       DO i = 1 , OutputData%C_obj%Fx_Len
          c_dbl_value(i) = OutputData%Fx(i)
       END DO
       CALL MAP_F2C_Output_Fx( OutputData%C_obj, c_dbl_value, OutputData%C_obj%Fx_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- Fy Output Data fields
    IF ( ASSOCIATED( OutputData%Fy ) ) THEN
       ALLOCATE( c_dbl_value(OutputData%C_obj%Fy_Len) )
       DO i = 1 , OutputData%C_obj%Fy_Len
          c_dbl_value(i) = OutputData%Fy(i)
       END DO
       CALL MAP_F2C_Output_Fy( OutputData%C_obj, c_dbl_value, OutputData%C_obj%Fy_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- Fz Output Data fields
    IF ( ASSOCIATED( OutputData%Fz ) ) THEN
       ALLOCATE( c_dbl_value(OutputData%C_obj%Fz_Len) )
       DO i = 1 , OutputData%C_obj%Fz_Len
          c_dbl_value(i) = OutputData%Fz(i)
       END DO
       CALL MAP_F2C_Output_Fz( OutputData%C_obj, c_dbl_value, OutputData%C_obj%Fz_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF

    ! -- wrtOutput Output Data fields
    IF ( ASSOCIATED( OutputData%wrtOutput ) ) THEN
       ALLOCATE( c_dbl_value(OutputData%C_obj%wrtOutput_Len) )
       DO i = 1 , OutputData%C_obj%wrtOutput_Len
          c_dbl_value(i) = OutputData%wrtOutput(i)
       END DO
       CALL MAP_F2C_Output_wrtOutput( OutputData%C_obj, c_dbl_value, OutputData%C_obj%wrtOutput_Len )
       DEALLOCATE( c_dbl_value )
    ENDIF
 END SUBROUTINE MAP_F2C_CopyOutput

  SUBROUTINE MAP_C2F_CopyOutput( OutputData, ErrStat, ErrMsg )
    TYPE(MAP_outputtype), INTENT(INOUT) :: OutputData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local 
    INTEGER(IntKi)                   :: i,i1,i2,i3,i4,i5,j,k
    REAL(KIND=C_DOUBLE) ,ALLOCATABLE :: c_dbl_value(:)
    REAL(KIND=C_DOUBLE) ,POINTER     :: dbl_arr(:)
    REAL(KIND=C_FLOAT)  ,ALLOCATABLE :: c_float_value(:)
    REAL(KIND=C_FLOAT)  ,POINTER     :: float_arr(:)
    INTEGER(KIND=C_INT) ,ALLOCATABLE :: c_int_value(:)
    INTEGER(KIND=C_INT) ,POINTER     :: int_arr(:)
    LOGICAL(KIND=C_BOOL),ALLOCATABLE :: c_bool_value(:)
    LOGICAL(KIND=C_BOOL),POINTER     :: bool_arr(:)
    ! 
    ErrStat = ErrID_None
    ErrMsg  = ""

    ! -- Fx Output Data fields
    IF ( ASSOCIATED( OutputData%Fx ) ) THEN
       CALL C_F_POINTER( OutputData%C_obj%Fx, dbl_arr, (/OutputData%C_obj%Fx_Len/) )
       DO i = 1, OutputData%C_obj%Fx_Len
          OutputData%Fx(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- Fy Output Data fields
    IF ( ASSOCIATED( OutputData%Fy ) ) THEN
       CALL C_F_POINTER( OutputData%C_obj%Fy, dbl_arr, (/OutputData%C_obj%Fy_Len/) )
       DO i = 1, OutputData%C_obj%Fy_Len
          OutputData%Fy(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- Fz Output Data fields
    IF ( ASSOCIATED( OutputData%Fz ) ) THEN
       CALL C_F_POINTER( OutputData%C_obj%Fz, dbl_arr, (/OutputData%C_obj%Fz_Len/) )
       DO i = 1, OutputData%C_obj%Fz_Len
          OutputData%Fz(i) = dbl_arr(i)
       END DO
    ENDIF

    ! -- wrtOutput Output Data fields
    IF ( ASSOCIATED( OutputData%wrtOutput ) ) THEN
       CALL C_F_POINTER( OutputData%C_obj%wrtOutput, dbl_arr, (/OutputData%C_obj%wrtOutput_Len/) )
       DO i = 1, OutputData%C_obj%wrtOutput_Len
          OutputData%wrtOutput(i) = dbl_arr(i)
       END DO
    ENDIF
 END SUBROUTINE MAP_C2F_CopyOutput

 SUBROUTINE MAP_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MAP_outputtype), INTENT(INOUT) :: SrcOutputData
   TYPE(MAP_outputtype), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ASSOCIATED(SrcOutputData%Fx)) THEN
   i1_l = LBOUND(SrcOutputData%Fx,1)
   i1_u = UBOUND(SrcOutputData%Fx,1)
   IF (.NOT. ASSOCIATED(DstOutputData%Fx)) THEN 
      ALLOCATE(DstOutputData%Fx(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MAP_CopyOutput: Error allocating DstOutputData%Fx.'
         RETURN
      END IF
   END IF
   DstOutputData%Fx = SrcOutputData%Fx
ENDIF
IF (ASSOCIATED(SrcOutputData%Fy)) THEN
   i1_l = LBOUND(SrcOutputData%Fy,1)
   i1_u = UBOUND(SrcOutputData%Fy,1)
   IF (.NOT. ASSOCIATED(DstOutputData%Fy)) THEN 
      ALLOCATE(DstOutputData%Fy(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MAP_CopyOutput: Error allocating DstOutputData%Fy.'
         RETURN
      END IF
   END IF
   DstOutputData%Fy = SrcOutputData%Fy
ENDIF
IF (ASSOCIATED(SrcOutputData%Fz)) THEN
   i1_l = LBOUND(SrcOutputData%Fz,1)
   i1_u = UBOUND(SrcOutputData%Fz,1)
   IF (.NOT. ASSOCIATED(DstOutputData%Fz)) THEN 
      ALLOCATE(DstOutputData%Fz(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MAP_CopyOutput: Error allocating DstOutputData%Fz.'
         RETURN
      END IF
   END IF
   DstOutputData%Fz = SrcOutputData%Fz
ENDIF
IF (ASSOCIATED(SrcOutputData%wrtOutput)) THEN
   i1_l = LBOUND(SrcOutputData%wrtOutput,1)
   i1_u = UBOUND(SrcOutputData%wrtOutput,1)
   IF (.NOT. ASSOCIATED(DstOutputData%wrtOutput)) THEN 
      ALLOCATE(DstOutputData%wrtOutput(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'MAP_CopyOutput: Error allocating DstOutputData%wrtOutput.'
         RETURN
      END IF
   END IF
   DstOutputData%wrtOutput = SrcOutputData%wrtOutput
ENDIF
  DstOutputData%C_obj = SrcOutputData%C_obj
     CALL MeshCopy( SrcOutputData%ptFairleadLoad, DstOutputData%ptFairleadLoad, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE MAP_CopyOutput

 SUBROUTINE MAP_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(MAP_outputtype), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL MeshDestroy( OutputData%ptFairleadLoad, ErrStat, ErrMsg )
 END SUBROUTINE MAP_DestroyOutput

 SUBROUTINE MAP_PackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MAP_outputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_ptFairleadLoad_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_ptFairleadLoad_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_ptFairleadLoad_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz    = Db_BufSz    + SIZE( InData%Fx )  ! Fx 
  Db_BufSz    = Db_BufSz    + SIZE( InData%Fy )  ! Fy 
  Db_BufSz    = Db_BufSz    + SIZE( InData%Fz )  ! Fz 
  Db_BufSz    = Db_BufSz    + SIZE( InData%wrtOutput )  ! wrtOutput 
 ! Allocate mesh buffers, if any (we'll also get sizes from these) 
  CALL MeshPack( InData%ptFairleadLoad, Re_ptFairleadLoad_Buf, Db_ptFairleadLoad_Buf, Int_ptFairleadLoad_Buf, ErrStat, ErrMsg, .TRUE. ) ! ptFairleadLoad 
  IF(ALLOCATED(Re_ptFairleadLoad_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_ptFairleadLoad_Buf  ) ! ptFairleadLoad
  IF(ALLOCATED(Db_ptFairleadLoad_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_ptFairleadLoad_Buf  ) ! ptFairleadLoad
  IF(ALLOCATED(Int_ptFairleadLoad_Buf))Int_BufSz = Int_BufSz + SIZE( Int_ptFairleadLoad_Buf ) ! ptFairleadLoad
  IF(ALLOCATED(Re_ptFairleadLoad_Buf))  DEALLOCATE(Re_ptFairleadLoad_Buf)
  IF(ALLOCATED(Db_ptFairleadLoad_Buf))  DEALLOCATE(Db_ptFairleadLoad_Buf)
  IF(ALLOCATED(Int_ptFairleadLoad_Buf)) DEALLOCATE(Int_ptFairleadLoad_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ASSOCIATED(InData%Fx) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%Fx))-1 ) =  PACK(InData%Fx ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%Fx)
  ENDIF
  IF ( ASSOCIATED(InData%Fy) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%Fy))-1 ) =  PACK(InData%Fy ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%Fy)
  ENDIF
  IF ( ASSOCIATED(InData%Fz) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%Fz))-1 ) =  PACK(InData%Fz ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%Fz)
  ENDIF
  IF ( ASSOCIATED(InData%wrtOutput) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%wrtOutput))-1 ) =  PACK(InData%wrtOutput ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%wrtOutput)
  ENDIF
  CALL MeshPack( InData%ptFairleadLoad, Re_ptFairleadLoad_Buf, Db_ptFairleadLoad_Buf, Int_ptFairleadLoad_Buf, ErrStat, ErrMsg, OnlySize ) ! ptFairleadLoad 
  IF(ALLOCATED(Re_ptFairleadLoad_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_ptFairleadLoad_Buf)-1 ) = Re_ptFairleadLoad_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_ptFairleadLoad_Buf)
  ENDIF
  IF(ALLOCATED(Db_ptFairleadLoad_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_ptFairleadLoad_Buf)-1 ) = Db_ptFairleadLoad_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_ptFairleadLoad_Buf)
  ENDIF
  IF(ALLOCATED(Int_ptFairleadLoad_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_ptFairleadLoad_Buf)-1 ) = Int_ptFairleadLoad_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_ptFairleadLoad_Buf)
  ENDIF
  IF( ALLOCATED(Re_ptFairleadLoad_Buf) )  DEALLOCATE(Re_ptFairleadLoad_Buf)
  IF( ALLOCATED(Db_ptFairleadLoad_Buf) )  DEALLOCATE(Db_ptFairleadLoad_Buf)
  IF( ALLOCATED(Int_ptFairleadLoad_Buf) ) DEALLOCATE(Int_ptFairleadLoad_Buf)
 END SUBROUTINE MAP_PackOutput

 SUBROUTINE MAP_UnPackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MAP_outputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_ptFairleadLoad_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_ptFairleadLoad_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_ptFairleadLoad_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ASSOCIATED(OutData%Fx) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Fx,1))); mask1 = .TRUE.
    OutData%Fx = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%Fx))-1 ),mask1,OutData%Fx)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%Fx)
  ENDIF
  IF ( ASSOCIATED(OutData%Fy) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Fy,1))); mask1 = .TRUE.
    OutData%Fy = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%Fy))-1 ),mask1,OutData%Fy)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%Fy)
  ENDIF
  IF ( ASSOCIATED(OutData%Fz) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Fz,1))); mask1 = .TRUE.
    OutData%Fz = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%Fz))-1 ),mask1,OutData%Fz)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%Fz)
  ENDIF
  IF ( ASSOCIATED(OutData%wrtOutput) ) THEN
  ALLOCATE(mask1(SIZE(OutData%wrtOutput,1))); mask1 = .TRUE.
    OutData%wrtOutput = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%wrtOutput))-1 ),mask1,OutData%wrtOutput)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%wrtOutput)
  ENDIF
 ! first call MeshPack to get correctly sized buffers for unpacking
  CALL MeshPack( OutData%ptFairleadLoad, Re_ptFairleadLoad_Buf, Db_ptFairleadLoad_Buf, Int_ptFairleadLoad_Buf, ErrStat, ErrMsg , .TRUE. ) ! ptFairleadLoad 
  IF(ALLOCATED(Re_ptFairleadLoad_Buf)) THEN
    Re_ptFairleadLoad_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_ptFairleadLoad_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_ptFairleadLoad_Buf)
  ENDIF
  IF(ALLOCATED(Db_ptFairleadLoad_Buf)) THEN
    Db_ptFairleadLoad_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_ptFairleadLoad_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_ptFairleadLoad_Buf)
  ENDIF
  IF(ALLOCATED(Int_ptFairleadLoad_Buf)) THEN
    Int_ptFairleadLoad_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_ptFairleadLoad_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_ptFairleadLoad_Buf)
  ENDIF
  CALL MeshUnPack( OutData%ptFairleadLoad, Re_ptFairleadLoad_Buf, Db_ptFairleadLoad_Buf, Int_ptFairleadLoad_Buf, ErrStat, ErrMsg ) ! ptFairleadLoad 
  IF( ALLOCATED(Re_ptFairleadLoad_Buf) )  DEALLOCATE(Re_ptFairleadLoad_Buf)
  IF( ALLOCATED(Db_ptFairleadLoad_Buf) )  DEALLOCATE(Db_ptFairleadLoad_Buf)
  IF( ALLOCATED(Int_ptFairleadLoad_Buf) ) DEALLOCATE(Int_ptFairleadLoad_Buf)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MAP_UnPackOutput


 SUBROUTINE MAP_Input_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(MAP_inputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(MAP_inputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: b3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: c3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: b4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: c4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: b5       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: c5       ! temporary for extrapolation/interpolation
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i11    ! dim1 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i21    ! dim1 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i31    ! dim1 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i41    ! dim1 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i51    ! dim1 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i61    ! dim1 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i71    ! dim1 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i81    ! dim1 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i91    ! dim1 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i12    ! dim2 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i22    ! dim2 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i32    ! dim2 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i42    ! dim2 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i52    ! dim2 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i62    ! dim2 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i72    ! dim2 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i82    ! dim2 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i92    ! dim2 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i03    ! dim3 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i13    ! dim3 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i23    ! dim3 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i33    ! dim3 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i43    ! dim3 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i53    ! dim3 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i63    ! dim3 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i73    ! dim3 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i83    ! dim3 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i93    ! dim3 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i04    ! dim4 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i14    ! dim4 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i24    ! dim4 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i34    ! dim4 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i44    ! dim4 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i54    ! dim4 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i64    ! dim4 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i74    ! dim4 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i84    ! dim4 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i94    ! dim4 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i05    ! dim5 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i15    ! dim5 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i25    ! dim5 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i35    ! dim5 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i45    ! dim5 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i55    ! dim5 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i65    ! dim5 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i75    ! dim5 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i85    ! dim5 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i95    ! dim5 level 9 counter variable for arrays of ddts
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in MAP_Input_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MAP_Input_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
IF (ASSOCIATED(u_out%x) .AND. ASSOCIATED(u(1)%x)) THEN
  u_out%x = u(1)%x
END IF ! check if allocated
IF (ASSOCIATED(u_out%y) .AND. ASSOCIATED(u(1)%y)) THEN
  u_out%y = u(1)%y
END IF ! check if allocated
IF (ASSOCIATED(u_out%z) .AND. ASSOCIATED(u(1)%z)) THEN
  u_out%z = u(1)%z
END IF ! check if allocated
  CALL MeshCopy(u(1)%PtFairDisplacement, u_out%PtFairDisplacement, MESH_UPDATECOPY, ErrStat, ErrMsg )
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MAP_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ASSOCIATED(u_out%x) .AND. ASSOCIATED(u(1)%x)) THEN
  ALLOCATE(b1(SIZE(u_out%x,1)))
  ALLOCATE(c1(SIZE(u_out%x,1)))
  b1 = -(u(1)%x - u(2)%x)/t(2)
  u_out%x = u(1)%x + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ASSOCIATED(u_out%y) .AND. ASSOCIATED(u(1)%y)) THEN
  ALLOCATE(b1(SIZE(u_out%y,1)))
  ALLOCATE(c1(SIZE(u_out%y,1)))
  b1 = -(u(1)%y - u(2)%y)/t(2)
  u_out%y = u(1)%y + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ASSOCIATED(u_out%z) .AND. ASSOCIATED(u(1)%z)) THEN
  ALLOCATE(b1(SIZE(u_out%z,1)))
  ALLOCATE(c1(SIZE(u_out%z,1)))
  b1 = -(u(1)%z - u(2)%z)/t(2)
  u_out%z = u(1)%z + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
  CALL MeshExtrapInterp1(u(1)%PtFairDisplacement, u(2)%PtFairDisplacement, tin, u_out%PtFairDisplacement, tin_out, ErrStat, ErrMsg )
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MAP_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MAP_Input_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MAP_Input_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ASSOCIATED(u_out%x) .AND. ASSOCIATED(u(1)%x)) THEN
  ALLOCATE(b1(SIZE(u_out%x,1)))
  ALLOCATE(c1(SIZE(u_out%x,1)))
  b1 = (t(3)**2*(u(1)%x - u(2)%x) + t(2)**2*(-u(1)%x + u(3)%x))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%x + t(3)*u(2)%x - t(2)*u(3)%x ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%x = u(1)%x + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ASSOCIATED(u_out%y) .AND. ASSOCIATED(u(1)%y)) THEN
  ALLOCATE(b1(SIZE(u_out%y,1)))
  ALLOCATE(c1(SIZE(u_out%y,1)))
  b1 = (t(3)**2*(u(1)%y - u(2)%y) + t(2)**2*(-u(1)%y + u(3)%y))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%y + t(3)*u(2)%y - t(2)*u(3)%y ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%y = u(1)%y + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ASSOCIATED(u_out%z) .AND. ASSOCIATED(u(1)%z)) THEN
  ALLOCATE(b1(SIZE(u_out%z,1)))
  ALLOCATE(c1(SIZE(u_out%z,1)))
  b1 = (t(3)**2*(u(1)%z - u(2)%z) + t(2)**2*(-u(1)%z + u(3)%z))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%z + t(3)*u(2)%z - t(2)*u(3)%z ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%z = u(1)%z + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
  CALL MeshExtrapInterp2(u(1)%PtFairDisplacement, u(2)%PtFairDisplacement, u(3)%PtFairDisplacement, tin, u_out%PtFairDisplacement, tin_out, ErrStat, ErrMsg )
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in MAP_Input_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE MAP_Input_ExtrapInterp


 SUBROUTINE MAP_Output_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(MAP_outputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(MAP_outputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: b3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: c3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: b4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: c4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: b5       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: c5       ! temporary for extrapolation/interpolation
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i11    ! dim1 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i21    ! dim1 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i31    ! dim1 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i41    ! dim1 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i51    ! dim1 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i61    ! dim1 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i71    ! dim1 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i81    ! dim1 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i91    ! dim1 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i12    ! dim2 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i22    ! dim2 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i32    ! dim2 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i42    ! dim2 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i52    ! dim2 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i62    ! dim2 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i72    ! dim2 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i82    ! dim2 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i92    ! dim2 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i03    ! dim3 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i13    ! dim3 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i23    ! dim3 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i33    ! dim3 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i43    ! dim3 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i53    ! dim3 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i63    ! dim3 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i73    ! dim3 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i83    ! dim3 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i93    ! dim3 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i04    ! dim4 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i14    ! dim4 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i24    ! dim4 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i34    ! dim4 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i44    ! dim4 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i54    ! dim4 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i64    ! dim4 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i74    ! dim4 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i84    ! dim4 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i94    ! dim4 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i05    ! dim5 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i15    ! dim5 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i25    ! dim5 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i35    ! dim5 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i45    ! dim5 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i55    ! dim5 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i65    ! dim5 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i75    ! dim5 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i85    ! dim5 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i95    ! dim5 level 9 counter variable for arrays of ddts
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in MAP_Output_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MAP_Output_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
IF (ASSOCIATED(u_out%Fx) .AND. ASSOCIATED(u(1)%Fx)) THEN
  u_out%Fx = u(1)%Fx
END IF ! check if allocated
IF (ASSOCIATED(u_out%Fy) .AND. ASSOCIATED(u(1)%Fy)) THEN
  u_out%Fy = u(1)%Fy
END IF ! check if allocated
IF (ASSOCIATED(u_out%Fz) .AND. ASSOCIATED(u(1)%Fz)) THEN
  u_out%Fz = u(1)%Fz
END IF ! check if allocated
IF (ASSOCIATED(u_out%wrtOutput) .AND. ASSOCIATED(u(1)%wrtOutput)) THEN
  u_out%wrtOutput = u(1)%wrtOutput
END IF ! check if allocated
  CALL MeshCopy(u(1)%ptFairleadLoad, u_out%ptFairleadLoad, MESH_UPDATECOPY, ErrStat, ErrMsg )
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MAP_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ASSOCIATED(u_out%Fx) .AND. ASSOCIATED(u(1)%Fx)) THEN
  ALLOCATE(b1(SIZE(u_out%Fx,1)))
  ALLOCATE(c1(SIZE(u_out%Fx,1)))
  b1 = -(u(1)%Fx - u(2)%Fx)/t(2)
  u_out%Fx = u(1)%Fx + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ASSOCIATED(u_out%Fy) .AND. ASSOCIATED(u(1)%Fy)) THEN
  ALLOCATE(b1(SIZE(u_out%Fy,1)))
  ALLOCATE(c1(SIZE(u_out%Fy,1)))
  b1 = -(u(1)%Fy - u(2)%Fy)/t(2)
  u_out%Fy = u(1)%Fy + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ASSOCIATED(u_out%Fz) .AND. ASSOCIATED(u(1)%Fz)) THEN
  ALLOCATE(b1(SIZE(u_out%Fz,1)))
  ALLOCATE(c1(SIZE(u_out%Fz,1)))
  b1 = -(u(1)%Fz - u(2)%Fz)/t(2)
  u_out%Fz = u(1)%Fz + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ASSOCIATED(u_out%wrtOutput) .AND. ASSOCIATED(u(1)%wrtOutput)) THEN
  ALLOCATE(b1(SIZE(u_out%wrtOutput,1)))
  ALLOCATE(c1(SIZE(u_out%wrtOutput,1)))
  b1 = -(u(1)%wrtOutput - u(2)%wrtOutput)/t(2)
  u_out%wrtOutput = u(1)%wrtOutput + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
  CALL MeshExtrapInterp1(u(1)%ptFairleadLoad, u(2)%ptFairleadLoad, tin, u_out%ptFairleadLoad, tin_out, ErrStat, ErrMsg )
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MAP_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MAP_Output_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MAP_Output_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ASSOCIATED(u_out%Fx) .AND. ASSOCIATED(u(1)%Fx)) THEN
  ALLOCATE(b1(SIZE(u_out%Fx,1)))
  ALLOCATE(c1(SIZE(u_out%Fx,1)))
  b1 = (t(3)**2*(u(1)%Fx - u(2)%Fx) + t(2)**2*(-u(1)%Fx + u(3)%Fx))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%Fx + t(3)*u(2)%Fx - t(2)*u(3)%Fx ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Fx = u(1)%Fx + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ASSOCIATED(u_out%Fy) .AND. ASSOCIATED(u(1)%Fy)) THEN
  ALLOCATE(b1(SIZE(u_out%Fy,1)))
  ALLOCATE(c1(SIZE(u_out%Fy,1)))
  b1 = (t(3)**2*(u(1)%Fy - u(2)%Fy) + t(2)**2*(-u(1)%Fy + u(3)%Fy))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%Fy + t(3)*u(2)%Fy - t(2)*u(3)%Fy ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Fy = u(1)%Fy + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ASSOCIATED(u_out%Fz) .AND. ASSOCIATED(u(1)%Fz)) THEN
  ALLOCATE(b1(SIZE(u_out%Fz,1)))
  ALLOCATE(c1(SIZE(u_out%Fz,1)))
  b1 = (t(3)**2*(u(1)%Fz - u(2)%Fz) + t(2)**2*(-u(1)%Fz + u(3)%Fz))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%Fz + t(3)*u(2)%Fz - t(2)*u(3)%Fz ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Fz = u(1)%Fz + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ASSOCIATED(u_out%wrtOutput) .AND. ASSOCIATED(u(1)%wrtOutput)) THEN
  ALLOCATE(b1(SIZE(u_out%wrtOutput,1)))
  ALLOCATE(c1(SIZE(u_out%wrtOutput,1)))
  b1 = (t(3)**2*(u(1)%wrtOutput - u(2)%wrtOutput) + t(2)**2*(-u(1)%wrtOutput + u(3)%wrtOutput))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%wrtOutput + t(3)*u(2)%wrtOutput - t(2)*u(3)%wrtOutput ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%wrtOutput = u(1)%wrtOutput + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
  CALL MeshExtrapInterp2(u(1)%ptFairleadLoad, u(2)%ptFairleadLoad, u(3)%ptFairleadLoad, tin, u_out%ptFairleadLoad, tin_out, ErrStat, ErrMsg )
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in MAP_Output_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE MAP_Output_ExtrapInterp

END MODULE MAP_Types
!ENDOFREGISTRYGENERATEDFILE
